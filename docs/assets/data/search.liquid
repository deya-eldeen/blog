


[ { "title" : "Significant Network Problems on MacBooks with Silicon Chips and Proposed Solutions", "category" : "", "tags" : " Development, iOS, Programming, Swift", "url" : "/significant-network-problems-on-macbooks-with-m1-m2-chips-with-proposed-solutions/", "date" : "February 2, 2024", "excerpt" : "As Apple‚Äôs Silicon processors have gained significant attention, many users have reported significant stability and network performance issues, particularly when using Wi-Fi on the 2.4 GHz band or connecting via a USB dongle for LAN. Networ...", "content" : "As Apple‚Äôs Silicon processors have gained significant attention, many users have reported significant stability and network performance issues, particularly when using Wi-Fi on the 2.4 GHz band or connecting via a USB dongle for LAN. Network Performance Issues on M1/M2 MacBooks Overview of Network IssuesOne common complaint among users is the sudden and prolonged drops in transfer rates, leading to frustrating experiences. These issues can often be attributed to the design of the network card in these devices, which may struggle to maintain consistent performance under certain conditions.When operating on the 2.4 GHz band, devices with Silicon processors may experience exceptionally low transfer rates, sometimes as low as 0.5 Mbps üò±. This is significantly lower than expected, and while not all devices are necessarily affected, numerous complaints have surfaced online.For instance, I experienced a connection that was about 30 times faster when using my MacBook Pro 2019 compared to the M1 Pro. Simple benchmarks using the networkQuality command revealed the following results:Benchmark ResultsM1 Pro Internet Speed: Downlink: 0.568 Mbps Uplink: 1.920 MbpsIntel-based Internet Speed: Downlink: 14.347 Mbps Uplink: 4.175 MbpsSuch results were shocking, especially considering I do not have fiber internet and rely on 4G. ü§£Initially, I suspected that VPN or MDM settings on the M1 Pro were causing these significant speed drops. However, further research led me to useful findings that helped restore speed on my M1 Pro device.Understanding Frequency BandsThe 2.4 GHz band offers better coverage and penetration through walls but is more susceptible to interference from other devices and nearby Wi-Fi networks. This can lead to congestion and speed drops, especially in crowded areas. Conversely, the 5 GHz band is generally faster and less prone to interference, although it has a shorter range and may struggle to penetrate solid objects.Additionally, connecting to a LAN via a USB dongle (especially when a monitor is connected to the same dongle) has been reported to cause network performance issues, complicating the challenges faced by users who rely on stable and high-speed connections.Proposed SolutionsWhile these problems may seem daunting, there are several potential workarounds and solutions that users can consider:1. Utilize Safe Mode for DiagnosticsWhen troubleshooting network performance issues on devices with Silicon processors, using the networkQuality command in safe mode can be a valuable diagnostic tool. Safe mode loads only essential components, allowing users to isolate potential software conflicts or third-party applications that may be impacting network performance. Running the networkQuality command in this environment can provide a clearer picture of the device‚Äôs network status.2. Switch to the 5 GHz BandSwitching to the 5 GHz band and disabling the 2.4 GHz network on your router can be an effective strategy for addressing performance issues. Additionally, using a 40 MHz channel width can help mitigate congestion and interference, resulting in improved network performance. This simple change can often make a noticeable difference in the reliability and speed of the Wi-Fi network for devices with Silicon processors.3. Consider Wi-Fi Over USB-C DonglesIf you are using a USB-C dongle for network connectivity and experiencing issues, consider switching to Wi-Fi as an alternative. Assess the network quality using networkQuality to compare the performance of the USB-C dongle with that of the Wi-Fi connection. This approach can help identify specific issues related to the dongle or the network environment.4. Disable Unused Network FeaturesDisabling unnecessary network features such as ‚ÄúThunderbolt Bridge,‚Äù which allows high-speed data transfer between two Mac computers using Thunderbolt ports, may also help. Users have reported that disabling features they do not use can resolve network performance issues.ConclusionIt‚Äôs crucial to be aware of these potential network performance issues when using devices with Silicon processors. While not all devices may be affected, many users have shared similar complaints. I hope this information proves helpful for those navigating network performance challenges on Silicon powered devices.By following the proposed solutions, users may find improved network stability and performance, enhancing their overall experience with these powerful machines." }, { "title" : "Test Doubles In Swift", "category" : "", "tags" : " Development, iOS, Programming, Swift", "url" : "/test-doubles-in-swift/", "date" : "October 25, 2023", "excerpt" : "The term test doubles draws inspiration from stunt doubles in the movie industry, where a stunt double steps in to perform dangerous or complex tasks, allowing the actor to focus on their role. Similarly, in software testing, test doubles step in ...", "content" : "The term test doubles draws inspiration from stunt doubles in the movie industry, where a stunt double steps in to perform dangerous or complex tasks, allowing the actor to focus on their role. Similarly, in software testing, test doubles step in to replace real components, making testing simpler, faster, and more reliable. Testing is an essential part of software development, ensuring the correctness and reliability of our code. However, when we test systems with many dependencies‚Äîlike databases, web services, or external APIs‚Äîwriting reliable tests can become challenging. This is where test doubles come in handy.It‚Äôs important to understand the basics of unit testing, see this blog post Gentle Introduction to Unit Testing, especially since certain architectural patterns, like MVC can introduce complexities that make them less testable. Familiarity with the FIRST principles‚ÄîFast, Independent, Repeatable, Self-validating, and Timely‚Äîis crucial for writing effective tests. Additionally, it‚Äôs vital to recognize that flaky tests, which produce inconsistent results, can undermine the reliability of your testing suite and lead to wasted time and effort.In this post, we‚Äôll explore the different types of test doubles, their purpose, and practical examples. By the end, you‚Äôll be able to confidently use them to create more effective, reliable tests.What is a Test Double?A test double is a substitute that stands in for a real dependency during testing. These dependencies, which can include external services, databases, or complex components, often introduce complexity that makes testing challenging. Test doubles enable us to isolate the code under test and concentrate on specific behaviors, resulting in more predictable and efficient tests. By using test doubles, we can create controlled environments that facilitate thorough testing without the overhead of managing real dependencies. This revision broadens the definition of a test double while maintaining clarity and focus on its purpose in testing.Test doubles mimic the behavior of real dependencies, but they provide simplified or controlled implementations. By replacing real dependencies with test doubles, we create an environment where we control every interaction, avoiding side effects from external systems.Types of Test DoublesThere are five common types of test doubles, each serving a distinct purpose: Dummy Fake Stub Spy MockLet‚Äôs dive into each of these with practical Swift examples. We‚Äôll use a sample UserManager class that has dependencies carefully picked for demonstrating all types of test doubles, it may be needed to create multiple test doubles of different types for each dependency in some cases, this depends on the test cases needs, but in this example, only one test double is created for each dependency, for demo purpose.UserManager also uses default values that can be changed, this is dependency injection by init.// UserManager.swiftclass UserManager { let loggerService: LoggerService let cacheService: CacheService let database: DatabaseHelper let securityHelper: SecurityHelper let notificationService: NotificationService init( logger: LoggerService = LoggerServiceImpl(), cache: CacheService = CacheServiceImpl(), database: DatabaseHelper = DatabaseHelperImpl(), securityHelper: SecurityHelper = SecurityHelperImpl(), notificationService: NotificationService = NotificationServiceImpl() ) { self.loggerService = logger self.cacheService = cache self.database = database self.securityHelper = securityHelper self.notificationService = notificationService } func authenticate(username: String, password: String) -&amp;gt; Bool { loggerService.log(&quot;Authenticating user \\(username) \\(password)&quot;) // Check cache first if let cachedPasswordHash = cacheService.get(username) { loggerService.log(&quot;Cache hit for user \\(username)&quot;) let success = cachedPasswordHash == password.hashed() securityHelper.recordAuthenticationAttempt(username: username, success: success) notificationService.sendAuthenticationEmail(username: username, success: success) return success } // Fetch from database if not in cache loggerService.log(&quot;Cache miss for user \\(username)&quot;) if let passwordHash = database.getUserPasswordHash(username: username) { cacheService.set(username, value: passwordHash) let success = passwordHash == password.hashed() securityHelper.recordAuthenticationAttempt(username: username, success: success) notificationService.sendAuthenticationEmail(username: username, success: success) return success } loggerService.log(&quot;Authentication failed for user \\(username)&quot;) securityHelper.recordAuthenticationAttempt(username: username, success: false) notificationService.sendFailedAuthenticationAttemptEmail(username: username, success: false) return false } func register(username: String, password: String) -&amp;gt; Bool { // Check if the username is valid guard !username.isEmpty, !password.isEmpty else { loggerService.log(&quot;Registration failed: Username or password is empty.&quot;) return false } // Check if the username already exists in the database if database.getUserPasswordHash(username: username) != nil { loggerService.log(&quot;Registration failed: Username \\(username) already exists.&quot;) return false // Username already taken } // Hash the password for storage let passwordHash = password.hashed() // Add the user to the database database.addUser(username: username, passwordHash: passwordHash) // Optionally, cache the newly created user cacheService.set(username, value: passwordHash) // Log the successful registration loggerService.log(&quot;User \\(username) registered successfully.&quot;) // Send a notification email (optional) notificationService.sendRegistrationEmail(username: username, success: true) return true }}Below you can see the protocols used to create our dependencies, for example the LoggerService protocol can be used to either created a LoggerServiceImpl or DummyLogger, and the same goes for other dependencies, each protocol can be used to create either an implementation or a test double, this way we ensure the code is properly testable, we can simply plug in whatever needed in the UserManager.// LoggerService.swiftprotocol LoggerService { func log(_ message: String)}// CacheService.swiftprotocol CacheService { func get(_ key: String) -&amp;gt; String? func set(_ key: String, value: String)}// DatabaseHelper.swiftprotocol DatabaseHelper { func getUserPasswordHash(username: String) -&amp;gt; String? func addUser(username: String, passwordHash: String)}// SecurityHelper.swiftprotocol SecurityHelper { func recordAuthenticationAttempt(username: String, success: Bool)}// NotificationService.swiftprotocol NotificationService { func sendAuthenticationEmail(username: String, success: Bool) func sendRegistrationEmail(username: String, success: Bool) func sendFailedAuthenticationAttemptEmail(username: String, success: Bool)}Below is a simple hasher, this is simplified for demo purpose.// String+Hasher.swiftextension String { func hashed() -&amp;gt; String { return &quot;hashed_\\(self)&quot; // Simplified hash for demo purpose. }}Below you can find the implementations we will be using in production code, this is useful to compare when reading about the test double examples.// LoggerServiceImpl.swiftclass LoggerServiceImpl: LoggerService { private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? &quot;com.yourapp&quot;, category: &quot;default&quot;) func log(_ message: String) { logger.log(&quot;Log: \\(message)&quot;) }}// CacheServiceImpl.swiftclass CacheServiceImpl: CacheService { private var cache: [String: String] = [:] func get(_ key: String) -&amp;gt; String? { return cache[key] // Retrieve value from cache } func set(_ key: String, value: String) { cache[key] = value // Store value in cache }}// DatabaseHelperImpl.swiftclass DatabaseHelperImpl: DatabaseHelper { private var users: [String: String] = [:] // Simulated user password storage func getUserPasswordHash(username: String) -&amp;gt; String? { return users[username] // Retrieve password hash for the given username } // Helper method to add users to the database for testing purposes func addUser(username: String, passwordHash: String) { users[username] = passwordHash // Add user to the simulated database }}// SecurityHelperImpl.swiftclass SecurityHelperImpl: SecurityHelper { private let logFileURL: URL init() { let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first! logFileURL = documentsURL.appendingPathComponent(&quot;authentication_log.txt&quot;) } func recordAuthenticationAttempt(username: String, success: Bool) { let logEntry = &quot;\\(Date()): Authentication attempt for \\(username): \\(success ? &quot;Success&quot; : &quot;Failure&quot;)\\n&quot; do { try logEntry.write(to: logFileURL, atomically: true, encoding: .utf8) } catch { print(&quot;Error writing to log file: \\(error)&quot;) } } func readAuthenticationAttempts() -&amp;gt; [(username: String, success: Bool)] { var attempts: [(username: String, success: Bool)] = [] do { let logContents = try String(contentsOf: logFileURL, encoding: .utf8) let lines = logContents.split(separator: &quot;\\n&quot;) for line in lines { // Parse each line to extract the username and success status let components = line.split(separator: &quot;:&quot;) if components.count &amp;gt;= 3 { let username = components[2].split(separator: &quot; &quot;)[3] // Extract the username let successString = components[3].trimmingCharacters(in: .whitespaces) // Extract &quot;Success&quot; or &quot;Failure&quot; let success = successString == &quot;Success&quot; attempts.append((username: String(username), success: success)) } } } catch { print(&quot;Error reading log file: \\(error)&quot;) } return attempts }}// NotificationServiceImpl.swiftclass NotificationServiceImpl: NotificationService { func sendAuthenticationEmail(username: String, success: Bool) { // Here you could implement logic to send an email notification print(&quot;Sent authentication email to \\(username): \\(success ? &quot;Success&quot; : &quot;Failure&quot;)&quot;) } func sendFailedAuthenticationAttemptEmail(username: String, success: Bool) { // Here you could implement logic to send an email notification for a failed attempt print(&quot;Sent failed authentication attempt email to \\(username)&quot;) } func sendRegistrationEmail(username: String, success: Bool) { // Here you could implement logic to send an email notification for registration print(&quot;Sent registration email to \\(username)&quot;) }}After getting familiar with UserManager, Let‚Äôs explore the different types of test doubles, along with examples and further details.1. DummiesA dummy test double is the simplest form of a test double. It‚Äôs used when a parameter is required by the method signature but isn‚Äôt actually used by the method itself. It‚Äôs essentially a placeholder to satisfy the API.Example:// DummyLogger.swiftclass DummyLogger: LoggerService { func log(_ message: String) { // No-op: This dummy logger does nothing }}In this example, DummyLogger is a dummy that satisfies the LoggerService protocol, but doesn‚Äôt actually perform any actions. It‚Äôs only used to fulfill the constructor requirements, notice that it has no Logger, in the unit tests cases, you can see the usage of that dummy, only to satisfy the needs we have.If we had a complicated logging system that is supposed to be tested, we simply create another test double for the LoggerService, but again, we are trying to demonstrate the different types of test doubles, and the logger in this case seems to be the most simple dependency.2. FakesA fake object provides a working implementation, but it is simpler and often less efficient than the real one. Fakes are often used to simulate databases or services during testing.Example:class FakeDatabase: DatabaseHelper { var users: [String: String] = [:] // Simulated user password storage func getUserPasswordHash(username: String) -&amp;gt; String? { return users[username] } // Helper method to add users to the fake database func addUser(username: String, passwordHash: String) { users[username] = passwordHash }}Here, the FakeDatabase simulates a database with an in-memory data structure, making it useful for testing without involving a real database. The original implementation is similar due to the demo-purpose, we can have the original implementation to really talk to a simple sqlite database or a coredata database.The fake test double only does a dictionary manipulation, using an original database example will make this blog post very lengthy, in the next example we can see a usage of user defaults.3. StubsA stub is a test double that provides predefined answers to method calls. Stubs don‚Äôt perform any logic; they just return canned responses. Stubs are helpful when you want to control the return values of a dependency in a test scenario.Example:// StubCache.swiftclass StubCache: CacheService { var storedData: [String: String] = [:] func get(_ key: String) -&amp;gt; String? { return storedData[key] // Simulates cache hit or miss } func set(_ key: String, value: String) { storedData[key] = value // Simulates setting a value in the cache }}If we compare with the original implementation, stubs use a dictionary to store data, instead of using UserDefaults.// CacheServiceImpl.swiftclass CacheServiceImpl: CacheService { private let userDefaults = UserDefaults.standard func get(_ key: String) -&amp;gt; String? { return userDefaults.string(forKey: key) // Retrieve value from UserDefaults } func set(_ key: String, value: String) { userDefaults.set(value, forKey: key) // Store value in UserDefaults }} Note: Stubs provide canned responses to method calls, while fakes provide a simplified implementation of the real thing. Note: the usage of UserDefaults should not be used with critical data storage like passwords, even if hashed, this is only for demo purpose.4. SpiesA spy is a test double that records information about the interactions with its methods, such as how many times a method was called or with what arguments. This makes it useful for verifying side effects in your tests.Example:// SpySecurityHelper.swiftclass SpySecurityHelper: SecurityHelper { var recordedAttempts: [(username: String, success: Bool)] = [] func recordAuthenticationAttempt(username: String, success: Bool) { recordedAttempts.append((username, success)) } // Helper method to check whether a specific attempt was recorded func verifyAttempt(username: String, success: Bool) -&amp;gt; Bool { return recordedAttempts.contains { $0.username == username &amp;amp;&amp;amp; $0.success == success } } // Helper method to check the total number of attempts func verifyTotalAttempts(expectedCount: Int) -&amp;gt; Bool { return recordedAttempts.count == expectedCount }}We can see that the SpySecurityHelper is more simple than the original implementation, the spy test double records all attempts of login, and checks the side effects of the dependency.5. MocksA mock is the most sophisticated type of test double. It allows you to set expectations about interactions with the object and verify that those expectations are met. Mocks are often used in combination with testing frameworks.Example:// MockNotificationService.swiftclass MockNotificationService: NotificationService { var sentEmails: [(username: String, success: Bool)] = [] func sendRegistrationEmail(username: String, success: Bool) { sentEmails.append((username, success)) } func sendAuthenticationEmail(username: String, success: Bool) { sentEmails.append((username, success)) } func sendFailedAuthenticationAttemptEmail(username: String, success: Bool) { sentEmails.append((username, success)) } // Helper to verify that an email was sent func verifyEmailSent(to username: String, success: Bool) -&amp;gt; Bool { return sentEmails.contains { $0.username == username &amp;amp;&amp;amp; $0.success == success } } // Helper to verify the total number of emails sent func verifyTotalEmailsSent(expectedCount: Int) -&amp;gt; Bool { return sentEmails.count == expectedCount }}Sample CodeIt‚Äôs best to use a real project to test our the code, you can download the source code Here. Simple SwiftUI Screen ConclusionTest doubles are a powerful concept that can significantly improve the reliability and maintainability of your tests. Whether you‚Äôre using dummies, fakes, stubs, spies, or mocks, each type of test double serves a unique purpose in ensuring your code is thoroughly tested in isolation.By understanding when and how to use each type, you‚Äôll be able to write more focused and effective unit tests in Swift, ensuring your code is both high quality and easier to maintain.Happy testing! üéâ" }, { "title" : "iOS Accessibility Basics", "category" : "", "tags" : " Development, iOS, Programming, Swift", "url" : "/ios-accessibility/", "date" : "August 2, 2023", "excerpt" : "Introduction to iOS AccessibilityiOS accessibility, from a developer‚Äôs perspective, refers to the set of tools, technologies, and guidelines provided by Apple that ensure iOS applications are usable and inclusive for people with disabilities. Acce...", "content" : "Introduction to iOS AccessibilityiOS accessibility, from a developer‚Äôs perspective, refers to the set of tools, technologies, and guidelines provided by Apple that ensure iOS applications are usable and inclusive for people with disabilities. Accessibility should not be an afterthought but an integral part of app development to create a seamless experience for all users. Why Accessibility MattersMaking your app accessible broadens your user base by including people with diverse needs such as visual, auditory, motor, and cognitive impairments. In addition to the social and ethical aspects, accessibility can positively affect your app‚Äôs user experience, engagement, and retention.Common Misconceptions about AccessibilityMany developers and businesses overlook accessibility for several reasons: Lack of awareness: Developers may not realize the significance and scope of accessibility. Perceived complexity: Implementing accessibility is often seen as difficult or time-consuming. Misaligned priorities: Businesses prioritize visual aesthetics or other features over accessibility. Costs and resources: There‚Äôs a belief that making apps accessible requires significant time, money, and resources. Assumed target audience: Developers sometimes think their audience does not include people with disabilities, which is rarely accurate.Despite these challenges, investing in accessibility not only benefits users with disabilities but also enhances the overall user experience for everyone. Let‚Äôs explore how accessibility laws and regulations play a role in encouraging more inclusive apps.Legal Implications of Non-ComplianceSeveral countries enforce digital accessibility through laws and regulations. In the United States, the Americans with Disabilities Act (ADA) and Section 508 of the Rehabilitation Act mandate accessibility for digital content offered by federal agencies or organizations that receive federal funding.Global Accessibility StandardsThe Web Content Accessibility Guidelines (WCAG), developed by the World Wide Web Consortium (W3C) and the Web Accessibility Initiative (WAI), are internationally recognized as the primary standard for ensuring digital accessibility. Adopting WCAG principles in your iOS app ensures it meets the needs of users with disabilities while avoiding legal risks.Legal Consequences for Non-ComplianceFailure to comply with accessibility regulations can lead to: Lawsuits: Companies may face legal action for failing to provide accessible digital experiences. Fines and penalties: Non-compliance can result in hefty fines and settlement costs. Reputational damage: Poor accessibility can harm a company‚Äôs image and alienate potential customers.Several high-profile cases, such as lawsuits against Domino‚Äôs Pizza, Netflix, and Target, have set important legal precedents. These cases highlight the need for accessibility in both websites and mobile applications, with courts ruling in favor of plaintiffs seeking more inclusive experiences.iOS Accessibility Tools and FeaturesAs an iOS developer, Apple provides various tools and APIs to incorporate accessibility features in your apps.VoiceOverVoiceOver is a built-in screen reader that allows users with visual impairments to interact with their devices using spoken feedback. It‚Äôs essential to ensure that your app supports VoiceOver by providing meaningful labels for UI elements and enabling users to navigate the app through gestures.Dynamic TextDynamic text allows users to adjust the size of the text to suit their reading preferences. To support this, make sure your app uses UIFontMetrics and resizable fonts so that text scales correctly across the interface.Switch Control and AssistiveTouchSwitch Control and AssistiveTouch help users with motor impairments to interact with their devices using alternate input methods. Developers can improve accessibility by ensuring that touch targets are large and well-spaced, and by supporting these alternative input methods.Closed Captions and SubtitlesFor users with auditory impairments, closed captions and subtitles are crucial. If your app includes audio or video content, providing closed captioning is essential to ensure accessibility.Types of Disabilities and How to Accommodate ThemIt‚Äôs crucial to understand the diverse range of impairments and how each can affect the user experience. Here‚Äôs a breakdown: Disability Type Accessibility Considerations Visual Users with visual impairments may rely on screen readers like VoiceOver or require high contrast modes. Ensure your app provides meaningful labels, supports dynamic text, and avoids color-only cues. Support users with conditions such as blindness, low vision, and color blindness. Auditory Users with hearing impairments depend on visual alternatives like subtitles, closed captions, and visual cues for alerts. Consider providing haptic feedback for notifications. Motor Users with limited dexterity benefit from larger touch targets and alternative input methods like Switch Control or voice commands. Simplifying interactions and allowing customizable gestures enhance usability. Cognitive Users with cognitive impairments may face challenges with memory, attention, or problem-solving. Clear instructions, simplified navigation, and minimal distractions improve the experience for these users. Speech Users with speech impairments might require alternative input methods like text-to-speech or communication aids. Consider incorporating Augmentative and Alternative Communication (AAC) tools. Situational Situational impairments, such as using an app in a noisy environment or under bright light, can benefit from features like closed captioning, adjustable brightness, and larger text sizes. Accessibility Best PracticesTo ensure your app meets accessibility standards, follow these best practices: Label UI Elements: Provide meaningful, descriptive labels for all interactive elements. Test with Assistive Technologies: Regularly test your app using tools like VoiceOver and Switch Control. Support Dynamic Type: Ensure your app adapts to various text sizes. Use Semantics: Make sure buttons, links, and other interactive elements have proper roles in accessibility APIs. Color and Contrast: Avoid relying solely on color to convey information, and maintain sufficient contrast for readability.ConclusionPrioritizing accessibility in your iOS app development process not only ensures compliance with laws and standards but also creates a more inclusive user experience. By incorporating these best practices and leveraging Apple‚Äôs powerful accessibility tools, you can build applications that are usable by everyone, regardless of their abilities.Accessibility is not just a feature‚Äîit‚Äôs a responsibility that every developer should embrace to ensure technology empowers all users." }, { "title" : "SwiftUI Views Are Values, Not Objects: Understanding the Implications", "category" : "", "tags" : " Development, iOS, Programming, Swift", "url" : "/swiftui-views-are-values-and-not-objects-overlooking-this-can-lead-to-bugs/", "date" : "May 19, 2023", "excerpt" : "In SwiftUI, views are fundamentally designed as value types rather than traditional objects. This design approach is a key aspect of SwiftUI‚Äôs declarative programming model and aligns with the Swift language‚Äôs emphasis on value semantics. Understa...", "content" : "In SwiftUI, views are fundamentally designed as value types rather than traditional objects. This design approach is a key aspect of SwiftUI‚Äôs declarative programming model and aligns with the Swift language‚Äôs emphasis on value semantics. Understanding this distinction is crucial for developers to avoid common pitfalls that can lead to bugs in their applications. üßê The Nature of Value Types in SwiftUIAs value types, views in SwiftUI are immutable. When you modify a view, you are actually creating a new instance with the desired changes rather than mutating the existing view. This immutability allows SwiftUI to efficiently track changes and perform targeted updates to the user interface. When state changes, SwiftUI can determine the minimal set of updates required to reflect the new state, enhancing performance and responsiveness.Benefits of Value Types Predictable Behavior: Since views are copied when needed, developers can expect consistent behavior, making it easier to manage state and data flow. Functional Programming Paradigm: Value types promote a more functional and declarative style of programming, allowing developers to describe the desired state while SwiftUI manages the view hierarchy. Thread Safety: Value types are inherently thread-safe, as copies are made when passing views between different execution contexts, reducing the risk of concurrency issues. Built-in Animations: SwiftUI can automatically animate changes by comparing old and new values of a view, resulting in smooth and visually appealing user interface updates. Declarative Programming ParadigmThe declarative programming paradigm is central to SwiftUI‚Äôs design philosophy. Instead of specifying step-by-step instructions on how to achieve a particular state, developers describe the desired state of the user interface. SwiftUI‚Äôs view tree engine leverages this approach to efficiently manage and update the user interface based on changes in the underlying state.Composable View HierarchyIn SwiftUI, you define your user interface using a hierarchy of composable and reusable views. Each view represents a specific part of the interface and is responsible for rendering itself based on the current state. This tree-like structure, known as the view hierarchy, is immutable. When the state changes, SwiftUI re-evaluates the view hierarchy and determines the necessary updates, a process known as the reconciliation algorithm (or diffing algorithm).The Reconciliation AlgorithmThe reconciliation algorithm is where SwiftUI‚Äôs view tree engine excels. It efficiently compares the old and new view hierarchies, identifies differences, and applies the necessary updates to the user interface. By only updating the specific parts of the view hierarchy that have changed, SwiftUI minimizes the workload needed to keep the UI in sync with the state, resulting in optimal performance.Comparison with UIKitIn contrast to UIKit, SwiftUI unifies view construction and updates into a single code path. Views are values rather than objects, described by values conforming to the View protocol. The view tree is transient and can be recreated at any time based on the underlying state. This declarative approach eliminates the need for separate event handlers and manual UI updates, as seen in UIKit. SwiftUI‚Äôs view tree engine efficiently reconciles state changes, performs targeted updates, and ensures a reactive UI that stays in sync with the data.By relying on value semantics, SwiftUI can perform granular updates and avoid unnecessary computations, leading to a highly performant and responsive user interface.Embracing a Declarative MindsetBy adopting a declarative approach, SwiftUI allows developers to focus on describing the desired end state of the UI rather than worrying about the low-level details of UI manipulation. This shift in mindset leads to more maintainable and expressive code, as developers can easily reason about the UI based on its desired state.Reactive Programming ModelAnother significant aspect of SwiftUI‚Äôs view tree engine is its ability to efficiently handle updates. As views in SwiftUI are value types, changes in the state result in the creation of new view instances rather than mutating existing ones. SwiftUI employs a mechanism called ‚Äúvalue comparison‚Äù to determine the differences between the old and new views, enabling it to perform targeted updates to the UI.Additionally, SwiftUI‚Äôs view tree engine embraces a reactive programming model. Views in SwiftUI are not just passive representations of UI elements; they react to changes in the state. This reactive nature ensures that the UI remains synchronized with the underlying data, providing a seamless user experience.ConclusionIn conclusion, SwiftUI‚Äôs view tree engine revolutionizes UI development by embracing the declarative programming paradigm. By leveraging value types, value comparisons, and reactive programming, SwiftUI provides an efficient and responsive user interface. The ability to describe UI in a declarative manner, combined with targeted updates and optimization techniques, empowers developers to create intuitive and performant user interfaces with ease. Understanding the value semantics of SwiftUI views is essential for building robust applications and avoiding common pitfalls that can arise from overlooking this fundamental aspect of the framework." }, { "title" : "This is Why I Don&#39;t Use Git GUI Tools", "category" : "", "tags" : " Development, iOS, Programming, Swift", "url" : "/this-is-why-i-dont-use-git-gui-tools/", "date" : "January 30, 2023", "excerpt" : "Almost anyone who uses Xcode can quickly notice that it lacks many essential Git features, which is acceptable in some way since it‚Äôs primarily a development environment rather than a dedicated source control application. The features av...", "content" : "Almost anyone who uses Xcode can quickly notice that it lacks many essential Git features, which is acceptable in some way since it‚Äôs primarily a development environment rather than a dedicated source control application. The features available in Xcode may suffice for personal or small projects, but when working within a larger team, relying solely on the IDE can lead to significant challenges in managing source control effectively. Xcode&#39;s Source Control Many engineers have also observed that file status markers like ‚ÄúA‚Äù (added), ‚ÄúM‚Äù (modified), and ‚ÄúC‚Äù (conflicted) often remain stuck, making it difficult to determine the current state of files at a glance.Convincing backend engineers to use the terminal is relatively straightforward, as GUI tools do not automatically update the repository‚Äôs trunk on a server daily at 1:30 AM. However, a cron job that utilizes the CLI can easily perform this task. On the other hand, persuading mobile developers may be more challenging since the need for terminal usage is not always immediately apparent.Real-Life Examples of Using the Git CLILet‚Äôs explore a few real-life examples that highlight the advantages of using the Git CLI over GUI tools. While I could list numerous cases, I will keep this post concise by focusing on a couple of key commands that illustrate the power of the terminal.1. PR RevertsGitHub introduced a feature for reverting pull requests (PRs). If you have an already merged PR and need to revert it before a tight deadline, using GitHub‚Äôs built-in revert feature does not provide details about which commits will be removed. This can lead to accidentally removing unrelated commits.By contrast, using the command:git revert --no-commit someHashgives you fine-grained control over which commits to remove or retain, allowing for a more precise and safe rollback.2. SubmodulesWhen dealing with nested Git repositories (submodules), many GUI tools lack robust support for managing these structures. The Git CLI, however, provides comprehensive commands to add, update, and manage submodules effectively.I typically keep the terminal open throughout the day; I can‚Äôt imagine working without it. I prefer understanding exactly what each command does rather than relying on button clicks in a GUI. While tools may come and go, the CLI remains the foundation upon which GUI tools are built.The Benefits of Using the Git CLIUsing the command line allows for the convenient setup of install scripts, build scripts, deployment scripts, and more. In a large team setting, it is often unclear what exactly happens within a GUI-based application. I‚Äôve witnessed colleagues make irreversible mistakes that could only be rectified using the CLI.I find that I am several times more productive using the command line compared to navigating through menus with a mouse. While Git GUI tools aim to simplify the process, they can inadvertently add complexity, especially in larger projects. I‚Äôve encountered non-standard terminology in some GUI tools that can make understanding Git more difficult.Xcode comes with a diffing tool, which visualize differences effectively. However, for serious Git users, mastering the command line is crucial. It provides the flexibility, control, and efficiency needed to manage complex projects and collaborate effectively with team members.Common Git CommandsHere is a table of common Git commands that I frequently use, sorted alphabetically, along with their descriptions: Command Description git add Stages changes in your working directory for the next commit. git annotate Displays the last modification of each line in a file, showing who made the change and when. git bisect Uses binary search to find the commit that introduced a bug. git blame Shows what revision and author last modified each line of a file. git checkout Switches branches or restores working tree files. git checkout -b Creates a new branch and switches to it. git cherry-pick Applies the changes introduced by an existing commit to your current branch. git clean -fdx Removes untracked files from your working directory, including ignored files. git clone Creates a copy of a remote repository on your local machine. git clone --single-branch Clones only the specified branch from a remote repository. git commit Records changes to the repository with a descriptive message. git commit --amend -m &quot;New commit message.&quot; Modifies the most recent commit with a new commit message. git config Configures Git settings, such as user information and repository-specific options. git diff Shows changes between commits, commit and working tree, etc. git diff --check Checks for whitespace errors in the changes. git fetch Downloads objects and refs from another repository without merging. git gc Cleans up unnecessary files and optimizes the local repository. git init Initializes a new Git repository in the current directory. git log Displays the commit history for the current branch. git log --all Shows the commit history for all branches. git log --oneline Displays a simplified view of the commit history, showing one line per commit. git log --summary Provides a summary of changes made in each commit, including file additions and deletions. git log -p Shows the patch (diff) introduced in each commit. git merge Combines changes from different branches into the current branch. git pull --rebase Fetches changes from a remote repository and rebases your current branch on top of them. git push Uploads local repository content to a remote repository. git push --set-upstream origin Sets the default remote branch for the current local branch. git push -u origin feature_branch_name Pushes the local branch to the remote repository and sets it to track the remote branch. git rebase Reapplies commits on top of another base tip, allowing for a cleaner project history. git remote -av Displays the remote repositories associated with the local repository. git remote add Adds a new remote repository to your local Git configuration. git reset --hard Resets the current branch to the specified state, discarding all changes in the working directory. git restore Restores files in the working directory to their last committed state. git revert Creates a new commit that undoes the changes made by a previous commit. git rm Removes files from the working directory and stages the removal for the next commit. git shortlog Summarizes the commit history, grouped by author. git show Displays information about a specific commit, including changes and commit message. git stash Temporarily saves changes in your working directory that are not ready to be committed. git stash list Lists all stashed changes. git stash pop Restores the most recently stashed changes and removes them from the stash list. git status Displays the state of the working directory and the staging area, showing which files are staged, modified, or untracked. git tag Creates a tag reference for a specific commit, often used for marking release points. git worktree Manages multiple working trees attached to the same repository, allowing you to work on different branches simultaneously." }, { "title" : "Why I Prefer To Store My Files On A Digital Ocean Space &amp; Not Google Drive Or Dropbox.", "category" : "", "tags" : " Development, iOS, Programming, Swift", "url" : "/backup-on-spaces/", "date" : "January 21, 2023", "excerpt" : "This is not directly related to swift or iOS, but thought it‚Äôs worth sharing, since I couldn‚Äôt find any article that mention such way to backup files. I‚Äôm one of those who experienced the evolution of data storage firsthand, starting with...", "content" : "This is not directly related to swift or iOS, but thought it‚Äôs worth sharing, since I couldn‚Äôt find any article that mention such way to backup files. I‚Äôm one of those who experienced the evolution of data storage firsthand, starting with floppy disks to back up HTML pages‚Äîspecifically 3DMax tutorials‚Äîduring my visits to internet caf√©s back in 2003. As technology advanced, I transitioned to using CDs, followed by DVDs, which offered greater storage capacity. I vividly remember the first flash drive my father gifted me as a teenager; it had a mere 128 MB of storage. At that time, such a device was considered a luxury and not affordable for many where I live. Fast forward to today, and we now have SSDs that are over 1000 times larger in capacity and available at significantly lower prices.Cloud StorageIn the realm of cloud storage, common solutions like Google Drive and Dropbox offer plans, such as a 2TB option for $10 monthly. However, I prefer utilizing my own mountable drive integrated with a Content Delivery Network (CDN) for distributing my files efficiently. The best solution I‚Äôve found for storing my work is using DigitalOcean Spaces, which is similar to AWS S3. I can conveniently mount it using a client like Cyberduck on my Mac, or on any device I own, allowing for seamless access and management of my files. This approach not only provides me with greater control over my data but also enhances my ability to share and distribute content effectively. Cyberduck, showing a Digital Ocean drive Serving static websites on DigitalOcean Spaces is entirely feasible by leveraging its S3-compatible object storage capabilities. To get started, you can upload your HTML, CSS, and JavaScript files directly to a Space, which acts as a repository for your website assets.Even serving static websites, such as React applications or Jekyll blogs, on DigitalOcean Spaces is entirely feasible by leveraging its S3-compatible object storage capabilities. To get started, you can upload your website files‚Äîwhether they are HTML, CSS, JavaScript. For example, when deploying a React app, you can build your project and upload the contents of the build folder to the Space. Similarly, for a Jekyll blog, you can generate the static site and upload the resulting files to your Space. Although DigitalOcean Spaces doesn‚Äôt natively support custom domains, you can set up a reverse proxy server using NGINX on a DigitalOcean Droplet to map your domain to the Space, allowing your static site to be accessed via your custom URL. This combination of tools enables you to efficiently serve your static websites while taking advantage of the scalability and performance of DigitalOcean‚Äôs infrastructure.Pros &amp;amp; ConsWhen considering a storage solution, it‚Äôs essential to weigh the advantages and disadvantages to determine the best fit for your needs. DigitalOcean Spaces offers a range of benefits that make it an appealing choice for developers and businesses alike. From cost-effectiveness to enhanced control over your files, the pros of using DigitalOcean Spaces can significantly enhance your workflow and file management capabilities. Below, we outline the key advantages of utilizing DigitalOcean Spaces, as well as some potential drawbacks to keep in mind, ensuring you have a comprehensive understanding of this powerful storage solution.Pros Direct Links: Easily access your files with straightforward URLs, allowing for seamless integration into your applications and workflows. Cost-Effective: With plans starting as low as $5, DigitalOcean Spaces provides an economical solution for storing and serving your data, making it accessible for individuals and small businesses alike. Bandwidth Savings: Setting up a Content Delivery Network (CDN) is simple, enabling you to save significant amounts of bandwidth and avoid exceeding transfer caps, which is especially beneficial for high-traffic applications. Granular Control: You have total control over metadata and content types of your files. For example, you can specify whether an uploaded MP4 file is streamable or downloadable, tailoring the user experience to your needs. Cross-Device Compatibility: DigitalOcean Spaces can be easily mounted on any device or server, providing flexibility and accessibility regardless of your operating system or hardware. Active File Serving: Unlike traditional storage solutions, your files are actively served, allowing you to host dynamic content, such as an Angular website, without placing additional load on your server. Custom URL Masking: You can mask the URL to reflect your own domain, enhancing professionalism and branding when presenting to clients or stakeholders during demos. Cons Technical Knowledge Requirement: Some users may find that utilizing DigitalOcean Spaces requires a certain level of technical knowledge, which could be a barrier for those unfamiliar with cloud storage solutions. Limited Client Options: Many desktop clients used to mount such drives are not open source or free, which may limit accessibility for some users. File Sharing Limitations: Files stored in DigitalOcean Spaces cannot be shared with specific individuals; they are either public or private, which may not suit all collaboration needs. SecurityDigitalOcean Spaces offers robust security features designed to protect your data effectively. One of the key aspects is access control, which allows users to manage permissions for files stored in Spaces.Use cases are infinite!The versatility of DigitalOcean Spaces opens up a myriad of use cases that can significantly enhance productivity and efficiency. For instance, if you‚Äôre involved in web scraping, you can effortlessly download large YouTube channels as a background job on the server. This approach allows you to avoid consuming your internet bandwidth while eliminating the need to keep a device running for extended periods. Instead, the files are stored directly in your DigitalOcean Space, making them readily accessible whenever you need them, without the hassle of local storage management. üßêMoreover, DigitalOcean Spaces functions similarly to a Network Attached Storage (NAS) solution, providing a centralized location for all your files that can be accessed from multiple devices. This capability is particularly beneficial for teams or individuals who require seamless file sharing and collaboration. Additionally, it can serve as a media center, allowing you to host and stream your multimedia content efficiently. Whether you‚Äôre managing a portfolio of projects, sharing resources with colleagues, or simply organizing personal media, the possibilities are truly endless with DigitalOcean Spaces.Another innovative use case for DigitalOcean Spaces is as a centralized repository for continuous integration and deployment (CI/CD) pipelines. Software engineers can utilize Spaces to store build artifacts, such as compiled binaries, Docker images, or deployment packages, generated during the CI/CD process. By configuring your CI/CD tools to upload these artifacts directly to DigitalOcean Spaces, you can ensure that all necessary files are easily accessible for deployment across various environments. This setup not only streamlines the deployment process but also provides a reliable and scalable solution for managing versioned artifacts, making it easier to roll back to previous versions if needed. Additionally, you can integrate Spaces with other services, such as monitoring and alerting tools, to keep track of deployment statuses and ensure smooth operations throughout the software development lifecycle.I‚Äôd love to hear how others are using DigitalOcean Spaces in their projects! Whether you‚Äôre leveraging it for web hosting, data storage, or as part of your CI/CD pipeline, your experiences and tips could be incredibly valuable. Share your thoughts and use cases in the comments below‚Äîlet‚Äôs learn from each other!" }, { "title" : "Gentle Introduction To Unit Testing.", "category" : "", "tags" : " Development, iOS, Programming, Swift", "url" : "/gentle-introduction-to-unit-testing/", "date" : "January 16, 2023", "excerpt" : "One Monday morning, a new developer, nicknamed Penguin üêß, started their first job as a software engineer. A conversation between Penguin and their team leader, Rex ü¶ñ, unfolded like this: Penguin üêß: I‚Äôve noticed that we have test cases wri...", "content" : "One Monday morning, a new developer, nicknamed Penguin üêß, started their first job as a software engineer. A conversation between Penguin and their team leader, Rex ü¶ñ, unfolded like this: Penguin üêß: I‚Äôve noticed that we have test cases written for almost all features in our mobile app. Why would we write unit tests if we have a QA team that does testing and quality assurance?Rex ü¶ñ: Writing unit tests doesn‚Äôt just ensure that features behave correctly after being developed or shipped; it also ensures that when someone writes new code, it doesn‚Äôt break any existing code. The QA team can‚Äôt test everything all over again when a new feature is introduced. It‚Äôs like an investment: you spend extra time writing unit tests while developing a feature, but you prevent potential bugs from happening in the future.A CI/CD job running all tests will prevent any developer from merging code that breaks an existing feature, provided that the feature has well-written tests. Tests can also serve as good documentation for anyone intending to read your code.Penguin üêß: My first function checks if the application needs a force update by comparing two version strings, like 1.0.2 and 1.1.2. Should my test function iterate through all possible cases, from the minimum value 000.000.000 to the maximum 999.999.999?Rex ü¶ñ: No! The idea of test cases is to cover edge cases and unexpected scenarios, like negative numbers in this example, along with a few random usual cases. You might consider writing test functions like:testWhenCurrentVersionIsLessThanRequiredVersionRequiresUpdatetestWhenRequiredVersionIsEqualToCurrentVersionRequiresNoUpdatetestMaximumMajorNumberComparesCorrectlytestMaximumMinorNumberComparesCorrectlytestMinimumPatchNumberComparesCorrectlytestMinimumMajorNumberComparesCorrectlytestMinimumMinorNumberComparesCorrectlytestMinimumPatchNumberComparesCorrectlytestMinimumNumbersComparesCorrectly‚Ä¶plus some random normal cases.Remember, the naming convention should show the developer‚Äôs intention, even if the test function name becomes lengthy. Covering all cases will make tests take a long time, possibly minutes in your case. You must avoid that. Unit tests need to be fast, ideally running in 50ms or less.Unit Tests Criteria ‚ÄúF.I.R.S.T‚Äù:The F.I.R.S.T criteria for unit tests is a set of principles designed to promote effective testing practices. It stands for Fast (tests should run quickly), Independent (tests should be self-contained), Repeatable (tests should yield consistent results), Self-Validating (tests should automatically determine pass or fail), and Timely (tests should be written alongside production code). These principles help ensure robust unit tests that improve code quality and simplify maintenance. Fast: We can run dozens of them in a second, if not more. Isolated: Should not depend on each other or any external state. Repeatable: They should always give the same result when they are run, like a pure function. Self-Verifying: The test must unambiguously say whether it passed or failed, with no room for interpretation. Timely: They should be written before or alongside the production code that you are testing.Penguin üêß: But we must have high test coverage, like 100% coverage to cover all cases, right?Rex ü¶ñ: Test coverage refers to the percentage of code logic that is tested, not the ‚Äúpossible values coverage.‚Äù By the way, test coverage is a flawed metric; it only means we have test functions that call our code. It doesn‚Äôt guarantee that the test functions are good.Penguin üêß: Got it. Are there any other benefits to having unit tests?Rex ü¶ñ: Testing reduces maintenance costs and the number of bugs. There are also other costs to consider, like customer impact. The longer an issue goes undiscovered, the more expensive it is, which can result in negative reviews, lost trust, and, of course, lost revenue!Penguin üêß: Why follow TDD (Test Driven Development) methodology? Why write the tests before writing the feature itself?Rex ü¶ñ: There are many development methodologies, like TDD, ATDD, DDD, BDD‚Ä¶ These are lengthy topics, and I encourage you to read about them. While TDD is a popular approach that includes the RGR (Red, Green, Refactor) lifecycle, it‚Äôs important to note that it‚Äôs not always the best choice for every situation. Consider the context of your project when choosing a methodology.Penguin üêß: That‚Äôs cool! How can I make sure my code is testable, and what makes it not testable?Rex ü¶ñ: You may consider architectural patterns that make code more modular and easier to test, like MVVM, VIPER, VIP, or even Functional Reactive Programming (FRP). Dependency injection, coordinator patterns, and pure functions also help make your code more testable.Penguin üêß: So I always need to mock stuff when testing, right?Rex ü¶ñ: There are various types of test doubles out there, not just mocks. You‚Äôve got fakes, stubs, spies, and dummies too! It might feel a bit overwhelming at first, but I encourage you to look into each one and learn when to use them effectively. Understanding their differences will really help you in your testing journey! (test doubles) term is derived from (stunt doubles) Penguin üêß: What other tips do you have?Rex ü¶ñ: Here are a few: In network testing for mobile apps, no HTTP request should be made. You test the networking feature itself. Tests run alphabetically, so you shouldn‚Äôt rename your tests to change their order of execution. Remember, tests should be independent; changing the order intentionally will break this criterion. Xcode provides performance tests that compare previous runs. You can also change the baseline, and it gives nicely formatted test coverage markers. Writing no tests is better than writing flaky tests!" }, { "title" : "Refresher: Solving Few Problems", "category" : "", "tags" : " Development, iOS, Programming, Swift, Math, Algorithms", "url" : "/problem_solving_swift_1_4/", "date" : "November 16, 2022", "excerpt" : "After reading the very popular book, Grokking Algorithms, I decided to blog about algorithms and data structures. I find the book is very informative and easy to digest. Grokking Algorithms book Understanding data structures is e...", "content" : "After reading the very popular book, Grokking Algorithms, I decided to blog about algorithms and data structures. I find the book is very informative and easy to digest. Grokking Algorithms book Understanding data structures is essential before diving into problem-solving. While I won‚Äôt go into detailed explanations here, I recommend attempting to solve the problems on your own without immediately referring to the solutions.Problem 1Return a pair of two distinct values (if any) that sum up to a target number, from a nonempty array that contains distinct integers.Here are different solutions with varying time complexities:// Time: O(n^2)func solution1(_ array: [Int], _ targetSum: Int) -&amp;gt; [Int] { for i in 0 ..&amp;lt; array.count-1 { for j in i+1 ..&amp;lt; array.count { if array[i] + array[j] == targetSum { return [array[i],array[j]] } } } return []}// Time: O(n^2)func solution2(_ array: [Int], _ targetSum: Int) -&amp;gt; [Int] { for i in array { for j in array { if (i != j) &amp;amp;&amp;amp; targetSum == (i + j) { return [i,j] } } } return []}// Time: O(n*log(n))func solution3(_ array: [Int], _ targetSum: Int) -&amp;gt; [Int] { let sorted = array.sorted() var leftPointer = 0 var rightPointer = sorted.count - 1 while leftPointer &amp;lt; rightPointer { let leftMost = sorted[leftPointer] let rightMost = sorted[rightPointer] let currentSum = leftMost + rightMost if currentSum == targetSum { return [leftMost, rightMost] } else if currentSum &amp;lt; targetSum { leftPointer = leftPointer + 1 } else if currentSum &amp;gt; targetSum { rightPointer = rightPointer - 1 } } return []}// Time: O(n)func solution4(_ array: [Int], _ targetSum: Int) -&amp;gt; [Int] { var numberDictionary = [Int: Bool]() for number in array { let mayMatch = targetSum - number if let exists = numberDictionary[mayMatch], exists { return [mayMatch, number] } else { numberDictionary[number] = true } } return []}Analysis:Each solution has its trade-offs in terms of time complexity. Running a simple benchmark on an array with 100,000 values yields the following results: solution1: 31.88 s. solution2: 18.41 s. solution3: 0.38 s. solution4: 0.20 s. üèÜAs you can see, solution 4 is the most efficient in this case, with a time complexity of O(n). The functions used for benchmarking are:func printTimeElapsedWhenRunningCode(title:String, operation:()-&amp;gt;()) { let startTime = CFAbsoluteTimeGetCurrent() operation() let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime print(&quot;Time elapsed for \\(title): \\(timeElapsed) s.&quot;)}func timeElapsedInSecondsWhenRunningCode(operation: ()-&amp;gt;()) -&amp;gt; Double { let startTime = CFAbsoluteTimeGetCurrent() operation() let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime return Double(timeElapsed)}Problem 2Given two non-empty arrays, write a function that determines if the second array is a subsequence of the first array. Keep in mind that a subsequence is not the same as a subarray.// Time: O(n)func isValidSubsequence_solution1(_ array: [Int], _ sequence: [Int]) -&amp;gt; Bool { if sequence.isEmpty { return false } if array == sequence { return true } if sequence.count &amp;gt; array.count { return false } var arrIdx = 0 var seqIdx = 0 while arrIdx &amp;lt; array.count, seqIdx &amp;lt; sequence.count { if array[arrIdx] == sequence[seqIdx] { seqIdx += 1 } arrIdx += 1 } return seqIdx == sequence.count}// Time: O(n)func isValidSubsequence_solution2(_ array: [Int], _ sequence: [Int]) -&amp;gt; Bool { if sequence.isEmpty { return false } if array == sequence { return true } if sequence.count &amp;gt; array.count { return false } var seqIdx = 0 for value in array { if seqIdx == sequence.count { break } if value == sequence[seqIdx] { seqIdx += 1 } } return seqIdx == sequence.count}Test Results:Using these arrays:let myArray1 = Array(stride(from: -900005, through: 900005, by: 1))let myArray2 = Array(stride(from: -900000, through: 900000, by: 1))The results were: Time elapsed for solution1: 28.102 s. Time elapsed for solution2: 14.446 s. üèÜSolution 2 is more efficient, even though both solutions have the same time complexity. Can you guess why? ü§ìProblem 3Write a function that takes in a non-empty array of integers sorted in ascending order and returns a new array with the squares of the original integers, also sorted in ascending order.Here are four solutions along with explanations:// Bad solution, appending is expensive; it&#39;s better to initialize an array with the required length.func sortedSquaredArray_solution1(_ array: [Int]) -&amp;gt; [Int] { var sortedSquares = [Int]() for value in array { sortedSquares.append(value * value) } return sortedSquares.sorted()}// Time: O(nlog(n)) | Space O(n)func sortedSquaredArray_solution2(_ array: [Int]) -&amp;gt; [Int] { var sortedSquares = Array(repeating: 0, count: array.count) for (idx, value) in array.enumerated() { sortedSquares[idx] = value * value } return sortedSquares.sorted()}// Using higher-order functions for high performance.func sortedSquaredArray_solution3(_ array: [Int]) -&amp;gt; [Int] { return array.map { $0 * $0 }.sorted()}// Time: O(n) | Space O(n)func sortedSquaredArray_solution4(_ array: [Int]) -&amp;gt; [Int] { var sortedSquares = Array(repeating: 0, count: array.count) var smallerValueIdx = 0 var largerValueIdx = array.count - 1 for idx in stride(from: array.count - 1, through: 0, by: -1) { let smallerValue = array[smallerValueIdx] let largerValue = array[largerValueIdx] if abs(smallerValue) &amp;gt; abs(largerValue) { sortedSquares[idx] = smallerValue * smallerValue smallerValueIdx += 1 } else { sortedSquares[idx] = largerValue * largerValue largerValueIdx -= 1 } } return sortedSquares}Benchmarking:For the input:let myArraySortedSquares = Array(stride(from: -5000000, through: 5000000, by: 1)) Time elapsed for solution1: 6.786 s. Time elapsed for solution2: 6.275 s. Time elapsed for solution3: 5.106 s. Time elapsed for solution4: 1.637 s. ü•áProblem 4Given a 2D array of matches [host, guest] and an array of results where 1 means the host team won, determine the player with the most wins.Example:let matches = [ [&quot;Nepomniachtchi&quot;, &quot;Grischuk&quot;], [&quot;Karjakin&quot;, &quot;Grischuk&quot;], [&quot;Nepomniachtchi&quot;, &quot;Keymer&quot;], [&quot;Ding Liren&quot;, &quot;Grischuk&quot;], [&quot;Karjakin&quot;, &quot;Andreikin&quot;], [&quot;Carlsen&quot;, &quot;Gukesh D&quot;], [&quot;Aronian&quot;, &quot;Gukesh D&quot;], [&quot;Carlsen&quot;, &quot;Andreikin&quot;], [&quot;Nepomniachtchi&quot;, &quot;Gukesh D&quot;], [&quot;Aronian&quot;, &quot;Gukesh D&quot;]]let results = [1, 1, 0, 0, 0, 0, 0, 1, 1, 1]import Foundationlet HOST_TEAM_WON = 1let WIN_POINTS = 1// O(n) time | O(k) space , where n: are matches and k is the number of teamsfunc chessWinner(_ matches: [[String]], _ results: [Int]) -&amp;gt; String { var bestPlayer = &quot;&quot; var scores = [String: Int]() scores[bestPlayer] = 0 for (idx, match) in matches.enumerated() { let (host, guest) = (match[0], match[1]) let winning = (results[idx] == HOST_TEAM_WON) ? (host) : (guest) if scores[winning] == nil { scores[winning] = 0} scores[winning] = scores[winning]! + WIN_POINTS if scores[winning]! &amp;gt; scores[bestPlayer]! { bestPlayer = winning } } return bestPlayer}func generateData() -&amp;gt; ([[String]] , [Int]) { let players1 = [&quot;Carlsen&quot;, &quot;Ding Liren&quot;, &quot;Nepomniachtchi&quot;, &quot;Karjakin&quot;, &quot;Aronian&quot;] let players2 = [&quot;Keymer&quot;, &quot;Vitiugov&quot;, &quot;Gukesh D&quot;, &quot;Andreikin&quot;, &quot;Grischuk&quot;] var matches = [[String]] () var results = [Int]() let possibleResults = [0,1] for _ in 0 ..&amp;lt; 10 { matches.append([players1.randomElement() ?? &quot;&quot;, players2.randomElement() ?? &quot;&quot;]) results.append(possibleResults.randomElement() ?? 0) } print(matches) print(results) return (matches, results)}func problem_04_solutions() { let data = generateData() printTimeElapsedWhenRunningCode(title:&quot;solution1&quot;) { let winner = chessWinner(data.0, data.1) print(winner) }}" }, { "title" : "iOS/Android Developer Security Basics", "category" : "", "tags" : " Development, iOS, Programming, Swift, Security, Math", "url" : "/ios-android-developer-security-basics/", "date" : "March 13, 2022", "excerpt" : "Mobile app security is a critical concern for both iOS and Android developers. This article aims to cover the essential security basics that every mobile developer should know. Presented as a conversation between two developers, Sam ü•∏ and Jomjom üíÄ...", "content" : "Mobile app security is a critical concern for both iOS and Android developers. This article aims to cover the essential security basics that every mobile developer should know. Presented as a conversation between two developers, Sam ü•∏ and Jomjom üíÄ, we‚Äôll explore various security concepts, risks, and best practices. JomJom! The Importance of Security in Mobile Developmentü•∏: What are the risks of not having good security precautions? Why do we spend so much on security?üíÄ: There are over 500 reported incidents of data breaches each year, with each incident costing an average of 3.5M to 5.0M USD. Remote work has increased these costs by 15%, as attackers find more opportunities when targets are spread across different locations.ü•∏: When people talk about security, the server is often seen as the main line of defense. Why should mobile developers be concerned if the server is secure?üíÄ: Even if the server is secure, mobile apps still need to implement security best practices. Mobile apps have direct access to sensitive data like location, contacts, and files. A compromised app could leak this information, posing significant risks. Unlike browsers, mobile apps run locally on devices without the same protections, making vulnerabilities in app code a target for attackers.Cross-Platform Security Concernsü•∏: But you‚Äôre an iOS developer, and I develop for Android. Are your tips applicable to Android too?üíÄ: Yes, many security precautions apply to both platforms, but it‚Äôs important to note that iOS and Android are based on different operating systems. iOS is based on Darwin (BSD), which is Unix-like, while Android is Linux-based. However, both platforms share common security concerns.ü•∏: Why can‚Äôt we just rely on HTTPS for security?üíÄ: HTTPS protects data in transit between the client and server, but only if the TLS certificate is valid and uncompromised. It‚Äôs just one layer of security; other aspects, like secure storage and code integrity, also need attention.Mobile Security Weak Pointsü•∏: What are the weak points in mobile security?üíÄ: Network, disk, and USB ports are common attack vectors. Understanding these entry points is key to securing your app.Key Security TerminologyüíÄ: Here are some essential terms you should know: Term Basic Explanation Authentication Establishing a user‚Äôs identity. Authorization Granting a user access to a resource. See this article for more. Cryptography The study of encryption and decryption techniques. Encryption Securing digital data using mathematical techniques and a key. Decryption Converting encrypted data back to its original form. Hashing Mapping data of arbitrary size to fixed-size values, often used for fingerprinting. Forensics The branch of digital science related to evidence found in computers and storage media. Sniffing Monitoring and capturing data packets in a network. HTTPS Hypertext Transfer Protocol Secure, a secure web protocol. SSL Secure Sockets Layer, a cryptographic protocol. TLS Transport Layer Security, the successor to SSL. IP Spoofing Creating IP packets with a modified source address to hide the sender‚Äôs identity. Reverse Engineering Deconstructing software or devices to extract design information. MITM Man-in-the-Middle, an attack where data between two parties is intercepted and potentially altered. XSS Cross-Site Scripting, an injection attack on web applications. SQL Injection An attack that exploits vulnerabilities in SQL queries. Read more here. OWASP Open Web Application Security Project, a nonprofit foundation focused on improving software security. MASVS Mobile Application Security Verification Standard, part of the OWASP Mobile Security Testing Guide. Mach-O binary The binary format used by iOS and macOS applications. Jailbreaking and Security Risksü•∏: Why are jailbroken devices a threat to app security?üíÄ: Jailbreaking allows users to bypass built-in security features, exposing the app to potential attacks. It‚Äôs best practice to prevent jailbroken devices from running your app. Check out my x04_checker repo for an iOS library that helps detect jailbroken devices.Debugging and Logging Concernsü•∏: They say debugging and print statements can be a security risk. Is that true?üíÄ: Yes, print statements are only active in development builds, but they can still send data to the USB interface. Also, NSLog statements remain in distribution builds, and users can access logs via the macOS Console app. Be careful not to log sensitive data or leave traces of code symbols.Certificate Pinning and Static Stringsü•∏: What about certificate pinning?üíÄ: Certificate pinning prevents attackers from using an invalid certificate to intercept data. Implementing dynamic certificate updates within the app is crucial to prevent tampering.ü•∏: And what about sensitive static strings?üíÄ: Never store sensitive strings in plist or other asset files. They are easily accessible and can expose your app to risks. This is usage of the `strings` tool, on macos, scanning some APK. The Risks of Third-Party Librariesü•∏: Why are third-party libraries risky for sensitive apps?üíÄ: While libraries are generally fine, they should be audited regularly. For sensitive apps, like banking, it‚Äôs better to minimize their use to avoid potential vulnerabilities.URL-Scheme Attacks and Universal Linksü•∏: What about URL-scheme attacks?üíÄ: When you define a URL scheme, your app can be launched by any link matching that scheme. However, other apps can register the same scheme, posing a risk. Universal links are a safer alternative.Final Thoughts on Mobile SecurityüíÄ: Achieving 100% security is impossible, but you can make attacking or cracking your app much more difficult. Remember, security is about increasing the cost and complexity of an attack relative to the value of the data.Some additional tips: Avoid Objective-C if possible; it‚Äôs easy to reverse engineer. Don‚Äôt log sensitive data. Disable keyboard caching for third-party keyboards. Store user credentials securely in the keystore or keychain. Implement App Transport Security and certificate pinning. Ensure data on disk and across the network is secure. Protect your application logic from reverse engineering. Avoid sharing sensitive data with third parties. Hide jailbreak detection deep within your app, not in the app delegate.Security isn‚Äôt just about making data impossible to access; it‚Äôs about balancing the cost and effort of data retrieval against its importance." }, { "title" : "Understanding GPS Hardware Basics for Mobile Developers", "category" : "", "tags" : " Development, iOS, Programming, Swift, Hardware, Math", "url" : "/gps-hardware-basics-for-software-engineers/", "date" : "March 10, 2022", "excerpt" : "Mobile software developers, whether working on iOS or Android, often use GPS functionality in their apps without fully understanding how GPS works. This article is designed to give you a basic understanding of GPS hardware, so you can appreciate t...", "content" : "Mobile software developers, whether working on iOS or Android, often use GPS functionality in their apps without fully understanding how GPS works. This article is designed to give you a basic understanding of GPS hardware, so you can appreciate the underlying technology and improve your app‚Äôs location-based features. This article is structured as a conversation between an iOS developer (Alex üë®üèª‚Äçüíª) and an electrical engineer (Sarah üë©üèº‚Äçüíª). Through their dialogue, we‚Äôll explore the fundamentals of GPS technology.The Basics of GPSüë®üèª‚Äçüíª: So what does GPS stand for?üë©üèº‚Äçüíª: It stands for Global Positioning System.üë®üèª‚Äçüíª: Who created it, and for what purpose?üë©üèº‚Äçüíª: The GPS project was launched by the United States in 1973 to overcome the limitations of earlier navigation systems.üë®üèª‚Äçüíª: I know GPS works without an internet connection, but do I need cellular service to use GPS?üë©üèº‚Äçüíª: No, you don‚Äôt need cellular service either.How GPS Works Without Internet or Cellular Serviceüë®üèª‚Äçüíª: How does GPS work without internet or cellular service?üë©üèº‚Äçüíª: Your device receives signals from satellites. There are about 24 operational satellites in six orbital planes.üë®üèª‚Äçüíª: Does my mobile need to connect to all of these satellites?üë©üèº‚Äçüíª: No, when stationary, your device only needs to receive signals from at least three satellites. When moving, it needs signals from four satellites for accurate positioning. GPS Satellites in Orbit (Source: Wikipedia) üë®üèª‚Äçüíª: How does the GPS system identify me and send data back?üë©üèº‚Äçüíª: The satellites don‚Äôt identify you. They continuously emit synchronized pulses everywhere. Your device simply receives these signals.Calculating Your Positionüë®üèª‚Äçüíª: How does my mobile determine my latitude, longitude, and altitude?üë©üèº‚Äçüíª: Your device compares the time it receives signals from each satellite. By calculating the time differences, it can determine your position on Earth. The satellites have highly accurate atomic clocks, which make these calculations possible. Calculating Position Using GPS Satellites üë®üèª‚Äçüíª: If the service is free and I don‚Äôt have a subscription for GPS, how is it funded?üë©üèº‚Äçüíª: GPS is one of several Global Navigation Satellite Systems (GNSS). Others include GLONASS, BeiDou, and Galileo. These systems are funded by governments and sometimes private entities. Commercial GPS receivers might have restrictions, like not functioning at high speeds. BeiDou GNSS, which doesn&#39;t have full Earth coverage Accuracy and Limitations of GPSüë®üèª‚Äçüíª: What is the typical error margin of GPS?üë©üèº‚Äçüíª: The error margin varies but is typically between 15 to 50 meters. Some systems use additional inertial sensors to provide more accurate positioning.üë®üèª‚Äçüíª: What is the minimum detectable distance?üë©üèº‚Äçüíª: Theoretically, the resolution is as fine as one inch, but in practice, it‚Äôs about three meters.Challenges of Using GPS Indoorsüë®üèª‚Äçüíª: I tried using GPS inside a large hospital, but the readings were inaccurate.üë©üèº‚Äçüíª: GPS signals do not work well indoors because they require a clear line of sight to the satellites.üë®üèª‚Äçüíª: But I still got some readings on my maps app indoors.üë©üèº‚Äçüíª: That‚Äôs likely the last known location. Some devices, like those from Huawei, augment GPS data with accelerometer and gyroscope data to simulate basic indoor navigation, but it‚Äôs not reliable.üë®üèª‚Äçüíª: What technologies are used for indoor navigation systems?üë©üèº‚Äçüíª: Indoor navigation typically uses beacons, Bluetooth, and other technologies. You might want to look into Apple AirTags for more information.Using Sensors for Positioningüë®üèª‚Äçüíª: Why can‚Äôt we just use the accelerometer and gyroscope in our phones to calculate position?üë©üèº‚Äçüíª: While you can derive some positional data from these sensors, they are prone to significant errors over time due to factors like drift and gimbal lock. Accelerometers and gyroscopes alone can‚Äôt provide absolute positioning, and their errors accumulate quickly.üë®üèª‚Äçüíª: That was a lot of information. Thanks for the explanation.üë©üèº‚Äçüíª: You‚Äôre welcome! See you soon.ConclusionUnderstanding how GPS works can help mobile developers better utilize location services in their apps. Whether you‚Äôre developing a navigation app or just curious about the technology behind the blue dot on your map, a basic knowledge of GPS hardware can enhance your approach to location-based features." }, { "title" : "Swift Sets: Basics and Practical Examples", "category" : "", "tags" : " Development, iOS, Programming, Swift, Data-Structures, Math", "url" : "/swift-set-data-structure-with-practical-example-pizza-cooking/", "date" : "March 8, 2022", "excerpt" : "Swift provides three main collection types: Arrays, Sets, and Dictionaries. In this post, we‚Äôll explore the basics of the Set data structure, understand its advantages, and walk through a practical example of using a set to manage ingredients for ...", "content" : "Swift provides three main collection types: Arrays, Sets, and Dictionaries. In this post, we‚Äôll explore the basics of the Set data structure, understand its advantages, and walk through a practical example of using a set to manage ingredients for making pizza. John Venn What is a Set?A Set in Swift is a collection of unique, unordered elements. Unlike arrays, sets do not maintain any particular order, and each value in a set is guaranteed to be unique. ‚ÄúYou use a set instead of an array when you need to test efficiently for membership and you aren‚Äôt concerned with the order of the elements in the collection, or when you need to ensure that each element appears only once in a collection.‚Äù‚Äî Swift DocumentationSets are fundamental in many areas of mathematics and computer science, particularly in set theory, which forms the basis of many mathematical concepts. A Venn diagram showing the intersection of two sets (Source: Wikipedia) Basic Set OperationsSwift provides a rich set of methods and properties to work with sets, allowing you to perform operations such as union, intersection, difference, and more. These operations are similar to those in mathematics.Common Set Operations Union: Combines all elements from two sets. Intersection: Returns only elements that exist in both sets. Difference: Returns elements in one set but not in the other. Subset: Checks if all elements of one set are contained in another. Superset: Checks if a set contains all elements of another set.In addition to these basic operations, Swift‚Äôs Set type supports many higher-order functions like map, filter, and more.func filterfunc isSubsetfunc isSupersetfunc isDisjointfunc subtractingfunc isStrictSupersetfunc isStrictSubsetfunc intersectionfunc map&amp;lt;T&amp;gt;func dropFirstfunc dropLastfunc dropfunc prefixfunc suffixfunc splitfunc firstIndexfunc shuffled&amp;lt;T&amp;gt;func shuffledfunc flatMap&amp;lt;ElementOfResult&amp;gt;func forEachfunc firstfunc withContiguousStorageIfAvailable&amp;lt;R&amp;gt;func enumeratedfunc minfunc maxfunc starts&amp;lt;PossiblePrefix&amp;gt;func elementsEqual&amp;lt;OtherSequence&amp;gt;func lexicographicallyPrecedes&amp;lt;OtherSequence&amp;gt;func containsfunc allSatisfyfunc reduce&amp;lt;Result&amp;gt;func reversedfunc flatMap&amp;lt;SegmentOfResult&amp;gt;func compactMap&amp;lt;ElementOfResult&amp;gt;func sortedfunc indexfunc formIndexfunc distancefunc randomElement&amp;lt;T&amp;gt;func randomElementfunc makeIteratorfunc isSubset&amp;lt;S&amp;gt;func isStrictSubset&amp;lt;S&amp;gt;func isSuperset&amp;lt;S&amp;gt;func isStrictSuperset&amp;lt;S&amp;gt;func isDisjoint&amp;lt;S&amp;gt;func union&amp;lt;S&amp;gt;func subtracting&amp;lt;S&amp;gt;func intersection&amp;lt;S&amp;gt;func symmetricDifference&amp;lt;S&amp;gt;func hashfunc joinedfunc joined&amp;lt;Separator&amp;gt;func encodefunc mapValues&amp;lt;T&amp;gt;func compactMapValues&amp;lt;T&amp;gt;func merging&amp;lt;S&amp;gt;func mergingPractical Example: Pizza Cooking with SetsLet‚Äôs dive into a practical example to illustrate how sets can be used in a real-world scenario:managing ingredients for making pizzaThis Swift code helps manage kitchen inventory and shopping lists for making pizza. It defines three sets: items currently in the kitchen items to be purchased necessary pizza ingredients.The code performs a union operation to combine the kitchen and shopping list items, identifies missing ingredients by subtracting the kitchen items from the shopping list, and updates the kitchen inventory accordingly.Finally, it checks if all required pizza ingredients are available, determining whether pizza can be made. Overall, the code efficiently ensures that you have everything needed to prepare a delicious pizza.// Datavar myKitchenItemsSet: Set = [&quot;Mozzarella&quot;,&quot;Mushrooms&quot;,&quot;Pineapples&quot;,&quot;Tomatoes&quot;,&quot;Mushrooms&quot;,&quot;Garlic&quot;]let shoppingListItemsSet: Set = [&quot;Olives&quot;, &quot;Tomatoes&quot;,&quot;Sourdough&quot;]let pizzaIngredientsSet: Set = [&quot;Sourdough&quot;,&quot;Mozzarella&quot;,&quot;Mushrooms&quot;,&quot;Tomatoes&quot;,&quot;Olives&quot;]// Perform union operation to combine kitchen items and shopping listlet union1 = myKitchenItemsSet.union(shoppingListItemsSet)let union2 = shoppingListItemsSet.union(myKitchenItemsSet)// Although union1 and union2 may appear different when printed, they are equal in contentprint(&quot;union1:&quot;, union1)print(&quot;union2:&quot;, union2)print(&quot;Are the unions equal?&quot;, (union1 == union2))// Find out what items are needed to complete the pizza ingredientslet itemsNeeded = shoppingListItemsSet.subtracting(myKitchenItemsSet)print(&quot;What I need to buy:&quot;, itemsNeeded)// Add the needed items to the kitchen itemsmyKitchenItemsSet.formUnion(itemsNeeded)// Check if all pizza ingredients are available in the kitchenlet canMakePizza = pizzaIngredientsSet.isSubset(of: myKitchenItemsSet)print(&quot;Can make pizza:&quot;, canMakePizza)Explanation of the Code Defining Sets: We start by defining sets for kitchen items, shopping list items, and pizza ingredients. Notice that duplicates in the set are automatically removed. Union Operation: We perform a union operation to combine items from the kitchen and the shopping list. Even though the order of union operations might differ, the sets remain equal. Subtraction: We subtract the kitchen items from the shopping list to find out what needs to be purchased. Forming Union: We then update the kitchen items set by adding the items we need to buy. Subset Check: Finally, we check if we have all the ingredients necessary to make the pizza.A More Advanced Example: Cooking for a Special GuestLet‚Äôs say you‚Äôre cooking a special pizza for Justin Bieber, who has some unusual ingredient preferences:var pizzaIngredientsForJustinSet: Set = [&quot;Sourdough&quot;,&quot;Mozzarella&quot;,&quot;Tomatoes&quot;,&quot;Olives&quot;,&quot;Amanita phalloides&quot;]print(&quot;Can I make pizza for Justin?&quot;, pizzaIngredientsForJustinSet.isSubset(of: myKitchenItemsSet))// Adding special ingredients to the kitchenmyKitchenItemsSet.insert(&quot;Rotten Mushrooms&quot;)myKitchenItemsSet.insert(&quot;Amanita phalloides&quot;)print(&quot;Can I make pizza for Justin now?&quot;, pizzaIngredientsForJustinSet.isSubset(of: myKitchenItemsSet))Here, we check if we can make a pizza with Justin‚Äôs preferred ingredients. Initially, it won‚Äôt work until we add the special ingredient ‚ÄúAmanita phalloides‚Äù to our kitchen items.Bridging Between Set and NSSetSwift allows you to bridge between Set and NSSet using the as operator. However, for bridging to be possible, the Element type of a set must be a class or a type that bridges to a Foundation type.Performance ConsiderationsSets are generally faster to process compared to arrays because of their unique, unordered nature. However, this comes at the cost of not being able to store duplicate values or maintain element order.ConclusionSwift‚Äôs Set data structure is a powerful tool for managing collections of unique items. Whether you‚Äôre working with ingredients in a kitchen or handling more complex data sets, understanding and leveraging sets can lead to more efficient and cleaner code." }, { "title" : "Using unicode markers (LTR: 0x200E, RTL:200F) to align &quot;hybrid RTL/LTR strings&quot; correctly.", "category" : "", "tags" : " Development, iOS, Programming, Swift, Interface-Builder, Xcode", "url" : "/using-invisible-markers-ltr-0x200e-rtl200f-to-align-hybrid-rtl-ltr-strings-correctly/", "date" : "March 3, 2022", "excerpt" : "So you have some text that contains both Arabic and English languages at the same time and are having difficulty aligning it? Sometimes it starts with English, and other times it starts with Arabic. Working With Multiple LanguagesIt‚Äôs com...", "content" : "So you have some text that contains both Arabic and English languages at the same time and are having difficulty aligning it? Sometimes it starts with English, and other times it starts with Arabic. Working With Multiple LanguagesIt‚Äôs common to encounter text that combines multiple languages, such as Arabic and English. However, this can lead to alignment issues, especially when the text direction changes unexpectedly. In this post, we‚Äôll explore how these challenges arise, examine a couple of solutions, and ultimately reveal the most effective method for ensuring proper text alignment using Unicode markers. Let‚Äôs dive in! This introduction sets the stage for the discussion by highlighting the relevance of the topic and outlining what the reader can expect to learn.The following example illustrates This problem üêõ A hacky way to solve it üë∫ The correct way to solve it üßê Top lineShows a line rendered incorrectly because the first word is Arabic, and it does not align as expected on the left ü§¶üèª.Middle lineOne hacky solution is to always start your text with a left-to-right (LTR) word, like text, but this is not the best approach üë∫.Bottom lineThis line displays correctly because it uses Unicode markers. The Unicode character set offers two markers: LTR (0x200E) and RTL (0x200F). These characters are invisible but control text direction. You can add \\u{200E} to force the wrapping direction. ‚úÖPlayground exampleimport UIKitimport PlaygroundSupportextension String { func withHighlighted(word: String) -&amp;gt; NSMutableAttributedString { let attributes = [ [NSAttributedString.Key.foregroundColor:UIColor.blue], [NSAttributedString.Key.font: UIFont.boldSystemFont(ofSize: 14)] ] let range = (self as NSString).range(of: word) let result = NSMutableAttributedString(string: self) for attribute in attributes { result.addAttributes(attribute, range: range) } return result }}class MyViewController : UIViewController { override func loadView() { let view = UIView() let topLabel = UILabel() let middleLabel = UILabel() let bottomLabel = UILabel() topLabel.frame = CGRect(x: 40, y: 40, width: 300, height: 20) middleLabel.frame = CGRect(x: 40, y: 80, width: 300, height: 20) bottomLabel.frame = CGRect(x: 40, y: 120, width: 300, height: 20) let word1 = &quot;ÿπÿ®ÿØ ÿßŸÑŸÑŸá&quot; let word2 = &quot;added a new comment&quot; let adjustor = &quot;\\u{200E}&quot; topLabel.attributedText = &quot;\\(word1) \\(word2)&quot;.withHighlighted(word: word1) middleLabel.attributedText = &quot;note: \\(word1) \\(word2)&quot;.withHighlighted(word: word1) bottomLabel.attributedText = &quot;\\(adjustor) \\(word1) \\(word2)&quot;.withHighlighted(word: word1) view.addSubview(topLabel) view.addSubview(middleLabel) view.addSubview(bottomLabel) self.view = view } }PlaygroundPage.current.liveView = MyViewController()" }, { "title" : "Mastering Swift Bitwise Operators: Theory and Practical Examples", "category" : "", "tags" : " Development, iOS, Programming, Swift, Bitwise", "url" : "/swift-bitwise-operators-with-real-examples/", "date" : "February 27, 2022", "excerpt" : "Bitwise operators are a powerful yet often underutilized feature in Swift. Unlike logical operators like &amp;quot;&amp;amp;amp;&amp;amp;amp;&amp;quot; and ||, which operate on entire values, bitwise operators perform operations on individual bits within a value....", "content" : "Bitwise operators are a powerful yet often underutilized feature in Swift. Unlike logical operators like &quot;&amp;amp;&amp;amp;&quot; and ||, which operate on entire values, bitwise operators perform operations on individual bits within a value. This post explores the different bitwise operators available in Swift, their theoretical underpinnings, and practical examples to demonstrate their utility in real-world scenarios. Overview of Bitwise OperatorsBitwise operators are crucial in low-level programming tasks such as manipulating flags, performing graphics operations, networking, and encryption. Here‚Äôs a summary of the primary bitwise operators in Swift: Operator Description &amp;amp; Binary AND \\| Binary OR ^ Binary XOR ~ Binary One‚Äôs Complement &amp;lt;&amp;lt; Binary Shift Left &amp;gt;&amp;gt; Binary Shift Right Truth Table for XORThe XOR (exclusive OR) operator is particularly interesting. It compares corresponding bits of two operands and returns 1 if the bits are different, and 0 if they are the same. Here‚Äôs the truth table for XOR: A B A ^ B TRUE TRUE FALSE TRUE FALSE TRUE FALSE TRUE TRUE FALSE FALSE FALSE Bitwise Operations in SwiftLet‚Äôs start by exploring how to represent integers as binary strings in Swift, and then apply various bitwise operators to them:extension Int { var binaryDescription: String { var binaryString = &quot;&quot; var internalNumber = self for _ in (1...self.bitWidth) { binaryString.insert(contentsOf: &quot;\\(internalNumber &amp;amp; 1)&quot;, at: binaryString.startIndex) internalNumber &amp;gt;&amp;gt;= 1 } return &quot;0b &quot; + binaryString }}func bitwiseExample() { let x1 = 0x1 let x2 = 0x2 print(&quot;x1\t&quot;, x1.binaryDescription ) print(&quot;x2\t&quot;, x2.binaryDescription ) let binaryAnd = (x1 &amp;amp; x2) let binaryOr = (x1 | x2) let binaryXor = (x1 ^ x2) let binaryComplement = (~x1) let binaryShiftL = (x1 &amp;lt;&amp;lt; 1) let binaryShiftR = (x1 &amp;gt;&amp;gt; 1) print(&quot;&amp;amp;\t&quot;, binaryAnd.binaryDescription ) print(&quot;|\t&quot;, binaryOr.binaryDescription ) print(&quot;^\t&quot;, binaryXor.binaryDescription ) print(&quot;~\t&quot;, binaryComplement.binaryDescription ) print(&quot;&amp;lt;&amp;lt;\t&quot;, binaryShiftL.binaryDescription ) print(&quot;&amp;gt;&amp;gt;\t&quot;, binaryShiftR.binaryDescription )}When executed, this code will output:x1 0b 0000000000000000000000000000000000000000000000000000000000000001x2 0b 0000000000000000000000000000000000000000000000000000000000000010&amp;amp; 0b 0000000000000000000000000000000000000000000000000000000000000000| 0b 0000000000000000000000000000000000000000000000000000000000000011^ 0b 0000000000000000000000000000000000000000000000000000000000000011~ 0b 1111111111111111111111111111111111111111111111111111111111111110&amp;lt;&amp;lt; 0b 0000000000000000000000000000000000000000000000000000000000000010&amp;gt;&amp;gt; 0b 0000000000000000000000000000000000000000000000000000000000000000Practical Applications of Bitwise OperatorsBitwise operators are not just theoretical‚Äîthey have practical uses in many areas of programming. Here are some real-world examples:1. Color Format ConversionA common use case for bitwise operators is converting a HEX color value into its RGB components in iOS development:extension UIColor { convenience init(red: Int, green: Int, blue: Int) { assert(red &amp;gt;= 0 &amp;amp;&amp;amp; red &amp;lt;= 255, &quot;Invalid red component&quot;) assert(green &amp;gt;= 0 &amp;amp;&amp;amp; green &amp;lt;= 255, &quot;Invalid green component&quot;) assert(blue &amp;gt;= 0 &amp;amp;&amp;amp; blue &amp;lt;= 255, &quot;Invalid blue component&quot;) self.init(red: CGFloat(red) / 255.0, green: CGFloat(green) / 255.0, blue: CGFloat(blue) / 255.0, alpha: 1.0) } convenience init(rgb: Int) { self.init( red: (rgb &amp;gt;&amp;gt; 16) &amp;amp; 0xFF, green: (rgb &amp;gt;&amp;gt; 8) &amp;amp; 0xFF, blue: rgb &amp;amp; 0xFF ) }}2. Quick &amp;amp; Dirty HashingBitwise operations can also be used to create simple hash functions. The chaoticHash function computes a chaotic hash value for a given string by mixing the ASCII values of its characters using bitwise operations and arithmetic. It starts with a prime constant to enhance distribution and applies multiple transformations to ensure that small changes in the input result in significantly different hash outputs.func chaoticHash(input: String) -&amp;gt; Int { var hashValue = 31 // Starting with a prime constant for better distribution for character in input { let asciiValue = Int(character.asciiValue ?? 0) hashValue ^= (asciiValue * 31) hashValue = (hashValue &amp;lt;&amp;lt; 5) | (hashValue &amp;gt;&amp;gt; (32 - 5)) hashValue += asciiValue hashValue ^= (hashValue &amp;gt;&amp;gt; 13) } return hashValue}let inputString = &quot;SwiftByDeya&quot;let hashValue = chaoticHash(input: inputString)print(&quot;Chaotic Hash Value: \\(hashValue)&quot;)// Outputs the computed chaotic hash value 3637872018676935840 Note: This hash function is not secure and should not be used in production environments.3. Base64 EncodingBase64 encoding involves converting a series of 8-bit bytes into 6-bit character lookup indexes. Bitwise operators like SHIFT, AND, OR, and NOT are crucial in performing these operations efficiently.4. Checking if a Number is Odd/EvenYou can quickly check if a number is odd or even using the following bitwise operations:func isEven(number: Int) -&amp;gt; Bool { return (number &amp;amp; 0x1) == 0}func isOdd(number: Int) -&amp;gt; Bool { return (number &amp;amp; 0x1) &amp;gt; 0}5. Efficiently Swapping Two VariablesBitwise XOR can be used to swap the values of two variables without using a temporary variable:var a = 5var b = 10a = a ^ bb = a ^ ba = a ^ b6. Network Address CalculationsBitwise operations are vital in calculating valid network addresses, subnet masks, and broadcast addresses in networking.7. Role-Based Access Control (RBAC)In role-based access control systems, bitwise operations are often used to calculate and manage permissions efficiently.8. Fast Inverse Square RootA famous example of bitwise operations is the fast inverse square root, used in graphics programming. The original implementation can be found here.ConclusionBitwise operators are a versatile tool in a Swift programmer‚Äôs toolkit. From manipulating individual bits to optimizing performance in specific tasks, understanding and leveraging bitwise operators can help you write more efficient and powerful code." }, { "title" : "Easily Tiling Images in Interface Builder Without Code", "category" : "", "tags" : " Development, iOS, Programming, Swift, Interface-Builder, Xcode", "url" : "/easily-tiling-images-in-interface-builder-without-code/", "date" : "February 23, 2022", "excerpt" : "Tiling images directly within Interface Builder, without writing code, can save time and simplify your UI design process. This post will guide you through the steps and provide additional tips to enhance your image tiling experience. Why ...", "content" : "Tiling images directly within Interface Builder, without writing code, can save time and simplify your UI design process. This post will guide you through the steps and provide additional tips to enhance your image tiling experience. Why Tile Images?Tiling images is a technique used to create repeating patterns or backgrounds in your app‚Äôs user interface. It‚Äôs particularly useful for creating seamless backgrounds or filling areas with a pattern that can expand or contract based on the device‚Äôs screen size. Step-by-Step Guide to Tiling Images1. Add an Image to Your Asset CatalogStart by adding the image you want to tile to your asset catalog in Xcode. Ensure the image is appropriately sized for tiling, meaning it should be able to repeat seamlessly.2. Enable Slicing in Interface BuilderOnce your image is in the asset catalog: Select the image asset. Go to the ‚ÄúEditor‚Äù menu. Choose ‚ÄúShow Slicing.‚ÄùThe image will now appear with a darker overlay and a ‚ÄúStart Slicing‚Äù button. This mode allows you to specify how the image should be sliced for tiling.3. Configure Slicing for TilingClick ‚ÄúStart Slicing‚Äù and select the appropriate slicing type. The slicing tool allows you to define insets for the image, which determine how the image is stretched or tiled. Edge Insets: Define the margins around the image that should remain unstretched. The central part of the image will be tiled. Center Mode: The center part of the image can be repeated or stretched depending on your configuration.In most cases, you‚Äôll want the Left, Right, Top, and Bottom insets to be zero, and the Width and Height to match the image dimensions. This setup ensures the image tiles seamlessly. Slicing Interface 4. Adjust Content Mode for Proper TilingTo ensure your image tiles correctly, set the image view‚Äôs content mode to Fill rather than Fit. The Fill mode repeats the image to fill the available space, whereas Fit scales the image to fit within the space, which may not give the desired tiling effect. Tiling Configuration Tips for Effective Tiling Use Seamless Patterns: Ensure your images are designed to tile seamlessly without visible edges or breaks. Experiment with Insets: Play around with different slicing insets to achieve creative tiling effects, such as borders or padding. Optimize Image Size: Large images can increase your app‚Äôs memory usage, so consider optimizing your images for size without sacrificing quality.Go Wild with Your ImaginationTiling offers endless possibilities for creativity in your app design. By experimenting with different images and configurations, you can create visually stunning interfaces. Below is an example of a simple pattern tiled across a view: Example of Tiled Images in Interface Builder ConclusionTiling images in Interface Builder without code is a powerful technique that can simplify your design process and enhance your app‚Äôs visual appeal. With the right tools and a bit of creativity, you can create dynamic, scalable backgrounds and patterns that elevate your user interface to the next level." }, { "title" : "Why my 0.3 MB image occupies around 10 MB on RAM?", "category" : "", "tags" : " Development, iOS, Programming, Swift, Performance, Graphics, Optimization", "url" : "/why-my-0-3-mb-image-takes-14-mb-on-ram/", "date" : "February 22, 2022", "excerpt" : "When developing applications, especially those that handle a large number of images, you may notice a significant difference between the disk size of an image and the amount of RAM it consumes. For example, you might have an image file that is onl...", "content" : "When developing applications, especially those that handle a large number of images, you may notice a significant difference between the disk size of an image and the amount of RAM it consumes. For example, you might have an image file that is only 0.3 MB on disk, yet it occupies around 10 MB of RAM when loaded. This post explores why this happens and what you can do to manage memory usage more effectively. Root Of Discrepancy?The primary reason for this discrepancy lies in how images are stored on disk versus how they are represented in memory. Images on disk are often compressed using formats like JPEG or PNG, which reduce file size by storing data more efficiently. However, when an image is loaded into RAM, it must be decompressed and converted into a raw bitmap format that the system can render on the screen. This raw format requires significantly more memory.The Formula for Memory UsageTo understand how much memory an image will consume, you can use the following formula:\\[\\scriptsize{\\text{Image Size on RAM} = (\\text{pixels height} \\times \\text{pixels width} \\times \\text{color depth bytes})}\\]Example: sRGB ImageConsider an image with dimensions 1568x960 pixels and an sRGB color profile, which uses 24 bits per pixel (or 3 bytes per pixel):The following image takes around 131 KB on disk and has an sRGB color profile, which is 24 bits (8 bits per channel). The size of the image on the RAM would be:\\[\\scriptsize{\\text{Image Size on RAM} = (\\text{1568} \\times \\text{960} \\times \\text{3}) \\text{ bytes} = 4,515,840 \\text{ bytes} = 4.3 MB}\\]Managing Image Memory UsageHigh memory usage from images can lead to performance issues, especially in memory-constrained environments like mobile devices. To mitigate this, you can employ several strategies:Downsampling ImagesOne effective way to reduce memory usage is to downsample images before loading them into memory. Downsampling reduces the image dimensions to match the display size, thus reducing the number of pixels and the overall memory required.Example in Swift with KingfisherIn Swift, Kingfisher comes with an option to downsize images according to the screen scale, so you can have images in a reasonable size even if they come largely from the server.import UIKitimport Kingfisherextension UIImageView { func setImageAsThumb(url:String) { let formattedURL = url.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? &quot;&quot; let scale = UIScreen.main.scale let resizingProcessor = ResizingImageProcessor(referenceSize: CGSize(width: 50.0 * scale, height: 50.0 * scale)) self.kf.setImage(with: URL(string: formattedURL), placeholder: nil, options: [.processor(resizingProcessor)]) }} As the two images in this post are the same size and color profile, they will occupy the same amount of RAM!Understanding Image Compression FormatsWhile JPEG and PNG are common image formats, they handle compression differently: JPEG: Lossy compression, which reduces file size by discarding some image data. It‚Äôs efficient for photos but less so for images with sharp edges or text. PNG: Lossless compression, which retains all image data. It‚Äôs better for images that need to preserve exact details but usually results in larger file sizes than JPEG.Both formats, when decompressed, will expand into a full bitmap that occupies significantly more memory.ConclusionUnderstanding how images are represented in memory versus on disk is crucial for optimizing your applications. While a compressed image file might be small, its memory footprint can be substantial due to the need to store it as a raw bitmap in RAM. By employing strategies like downsampling, you can better manage memory usage and improve your application‚Äôs performance." }, { "title" : "Why You Should Never Use Floating-Point or Double Data Types for Money Calculations!", "category" : "", "tags" : " Development, iOS, Programming, Swift", "url" : "/never-use-floating-point-double-data-types-for-monetary-calculations/", "date" : "February 12, 2022", "excerpt" : "Handling money in software is a task that requires precision, especially when dealing with fractions of currency like dollars and cents. One common mistake that developers make is using floating-point data types, such as Double, to represent monet...", "content" : "Handling money in software is a task that requires precision, especially when dealing with fractions of currency like dollars and cents. One common mistake that developers make is using floating-point data types, such as Double, to represent monetary values. This post explains why this is problematic and what alternatives you should use. Avoid Floating-Point for Monetary Values The Problem with Floating-Point ArithmeticFloating-point values, including the Double type in Swift, should be avoided when working with currency amounts that have fractions. The fundamental issue is that floating-point types cannot represent certain decimal values exactly due to their binary nature.Example Showing Unexpected ResultsConsider the following example where you want to store 0.1 dollars:var balance: Double = 0.0for _ in 1...10{ balance += 0.1}for _ in 1...10{ balance -= 0.1}print(balance) // Outputs: 2.7755575615628914e-17Here, the expected value is 0.0 but we get 2.7755575615628914e-17 since value 0.1 is not stored precisely as 0.1 but as an approximation (e.g., 0.10000000149‚Ä¶). This small difference can have significant consequences, especially when performing multiple arithmetic operations.Loss of SignificanceWhen performing a series of arithmetic operations using floating-point numbers, you may encounter a problem known as loss of significance. This occurs when the precision errors from approximations accumulate, leading to larger errors that can affect the outcome of your calculations.Let‚Äôs consider a scenario where you repeatedly add 0.1 dollars to an account balance:var balance: Double = 0.0for _ in 1...100 { balance += 0.1}print(balance) // Outputs: 9.9999999999999999Instead of getting the expected 10.0, the result is slightly off due to accumulated floating-point errors. This can be particularly troublesome in financial applications where accuracy is critical.The Correct Approach: Use Decimal or NSDecimalNumberTo avoid the pitfalls of floating-point arithmetic, you should use the Decimal type in Swift, which is designed for precise decimal arithmetic. The Decimal type can represent numbers exactly as they appear, making it suitable for financial calculations.Example: Using DecimalHere‚Äôs how you can correctly handle monetary values using Decimal:let myBalance: Decimal = 12.333let result = myBalance / 3print(result) // Outputs: 4.111In this example, the division operation yields the expected result with no loss of precision.Converting Double to DecimalIf you need to work with a value initially stored as a Double, you can convert it to a Decimal using NSNumber:let doubleValue: Double = 12.333let decimalValue: Decimal = NSNumber(floatLiteral: doubleValue).decimalValuelet result = decimalValue / 3print(result) // Outputs: 4.111By converting to Decimal, you can ensure that your calculations are accurate and free from the issues associated with floating-point arithmetic.ConclusionWhen it comes to monetary calculations, accuracy is paramount. The floating-point types, including Double, should be avoided due to their inherent imprecision. Instead, use Decimal or NSDecimalNumber to ensure that your financial calculations are accurate and reliable. This small change can save you from potential bugs and errors in your applications, especially those dealing with money." }, { "title" : "Swift: The Difference Between Void and ()", "category" : "", "tags" : " Development, iOS, Programming, Swift", "url" : "/swift-void-and/", "date" : "November 29, 2021", "excerpt" : "Void is a concept familiar across many programming languages. In Swift, Void has a unique and specific meaning, rooted in the language‚Äôs type system.This post explores the intricacies of Void in Swift, how it relates to the empty tuple (), and how...", "content" : "Void is a concept familiar across many programming languages. In Swift, Void has a unique and specific meaning, rooted in the language‚Äôs type system.This post explores the intricacies of Void in Swift, how it relates to the empty tuple (), and how it is used in functions, methods, and closures. What is Void in Swift?In Swift‚Äôs standard library, Void is simply a typealias for an empty tuple (). This is important because Swift, unlike many other languages, treats Void as a type, which is crucial in a language that emphasizes type safety.public typealias Void = ()The above definition means that Void is nothing more than a convenient way to refer to an empty tuple. When a function doesn‚Äôt return any value, Swift allows you to specify the return type as Void. However, if you omit the return type, Swift implicitly assumes the function returns Void.Void and Type SafetyIn Swift, type safety is a core principle. The concept of Void as an empty tuple fits neatly into this system, ensuring that functions, methods, and closures that don‚Äôt return a value still conform to Swift‚Äôs type system.Consider the following function:func doSomething() -&amp;gt; Void { print(&quot;Doing something&quot;)}This is functionally equivalent to:func doSomething() { print(&quot;Doing something&quot;)}In both cases, doSomething returns Void, but the explicit version makes it clear that no value is expected from the function.The Empty Tuple ()In Swift, () can represent both a type and a value. As a type: () is the empty tuple type, which is equivalent to Void. As a value: () is an empty tuple, which is equivalent to Void().This dual role can sometimes cause confusion, especially for developers coming from other programming languages where Void is a keyword rather than a type.Practical Uses of VoidUnderstanding Void as a type opens up some practical applications in Swift, particularly in generic programming and higher-order functions.Example: Using Void in a Closurelet completionHandler: () -&amp;gt; Void = { print(&quot;Task completed&quot;)}completionHandler()Here, the closure completionHandler takes no parameters and returns Void. This pattern is common in asynchronous programming, where closures often signal the completion of a task.Void and () in Swift Optional Void: You can have an Optional&amp;lt;Void&amp;gt; in Swift, which can be useful when you want to represent the presence or absence of a side-effect without returning an actual value.var action: (() -&amp;gt; Void)?action = { print(&quot;Action performed!&quot;)}// Executing the action if it existsaction?() Higher-Order Functions: Void can be used in higher-order functions where you need to define a function that takes a function as a parameter and returns Void. func executeTask(task: () -&amp;gt; Void) { task()} executeTask { print(&quot;Executing task&quot;)} Void is Not the Same as voidIn languages like C, C++, and Objective-C, void is a keyword that indicates a function doesn‚Äôt return a value. In Swift, Void is a type, which means you can do things with Void that you couldn‚Äôt do with void in other languages, such as using Void in type constraints or as a generic parameter.This function works with any type and explicitly states that it returns Void.SummaryIn Swift, Void is more than just a synonym for ‚Äúno return value‚Äù; it is a type that integrates smoothly with Swift‚Äôs emphasis on type safety and flexibility. Understanding Void as an empty tuple () provides deeper insights into how Swift handles functions, closures, and type constraints.By leveraging Void, you can write more expressive, safer, and more flexible Swift code, whether you‚Äôre working on simple functions or complex generic algorithms. Keep in mind: Void is not just an absence of a return type‚Äîit‚Äôs an integral part of Swift‚Äôs type system that enables type-safe, expressive code." }, { "title" : "Swift: The Difference Between nil, Nil, NULL, NSNull", "category" : "", "tags" : " Development, iOS, Programming, Swift, Objective-C", "url" : "/swift-the-difference-between-nil-nil-null-nsnull/", "date" : "November 27, 2021", "excerpt" : "As a programmer, you will often need to represent the concept of ‚Äúnothingness.‚Äù In Swift and Objective-C, this idea manifests in various forms: nil, Nil, NULL, and NSNull. Each of these serves a distinct purpose and is used in different contexts. ...", "content" : "As a programmer, you will often need to represent the concept of ‚Äúnothingness.‚Äù In Swift and Objective-C, this idea manifests in various forms: nil, Nil, NULL, and NSNull. Each of these serves a distinct purpose and is used in different contexts. Understanding these concepts is fundamental to mastering memory management, type safety, and interoperability between Swift and Objective-C. Understanding the KeywordsWhen dealing with programming languages like Swift and Objective-C, it‚Äôs crucial to grasp how they handle the concept of ‚Äúnothing.‚Äù This ‚Äúnothing‚Äù can be expressed in different ways: nil, Nil, NULL, and NSNull. These terms, while similar in appearance, have distinct meanings and uses.The Concept of ‚ÄúNull‚Äù in ProgrammingIn many programming languages, including C, Objective-C, and Swift, ‚Äúnull‚Äù represents the absence of a value or a reference to an object that doesn‚Äôt exist. This is a crucial concept because it allows programs to handle cases where data is missing, uninitialized, or optional. However, how ‚Äúnull‚Äù is implemented and used can vary between languages and contexts.NULLNULL is a macro in C and Objective-C, typically defined as ((void*)0). It represents a null pointer, which is a pointer that doesn‚Äôt point to any memory location. In C-based languages, it‚Äôs common to use NULL to indicate that a pointer is not currently pointing to any valid object or memory address. In Objective-C, NULL is often used for pointers to non-object types, such as structures or primitive data types.In practice, NULL is crucial for error handling and conditional logic, allowing developers to check whether a pointer is valid before attempting to use it. For example:int *ptr = NULL;if (ptr == NULL) { // Handle the case where ptr is not pointing to anything}nilIn Objective-C, nil is used to represent a null pointer to an object. It is essentially a way to say ‚Äúthis object does not exist.‚Äù Defined as #define nil NULL, it is functionally equivalent to NULL but is specifically intended for use with Objective-C objects. When a message is sent to nil, nothing happens; it returns a value of 0 or nil, depending on the expected return type. This behavior simplifies error handling in Objective-C, as it avoids crashes that would occur if you attempted to send a message to an uninitialized object.Here‚Äôs an example:NSString *string = nil;if (!string) { // The string is nil, handle accordingly}NilNil is similar to nil, but it is used specifically for class pointers in Objective-C. When a class variable is Nil, it indicates that the class does not exist. This distinction is important because Objective-C differentiates between instances of classes (objects) and the classes themselves. For instance, Nil might be used when checking if a class has been defined or loaded into memory.NSNullNSNull is an Objective-C class that provides a way to represent null values in collection objects such as NSArray, NSDictionary, and NSSet. These collections do not allow nil values because nil is used to signify the absence of an object. Instead, [NSNull null] acts as a placeholder for nil in these cases.For example, if you want to store a null value in an array:NSArray *array = @[[NSNull null]];In this array, the first (and only) element is [NSNull null], representing a null value.Swift and Objective-C InteroperabilitySwift, being a more modern language, handles ‚Äúnothingness‚Äù differently. In Swift, nil is not a pointer but rather the absence of a value of a certain type. This difference is crucial when working with Swift and Objective-C together, particularly in projects where both languages are used.Example: Interacting with Objective-C Code in SwiftConsider the following Objective-C code:// Machine.h#import &amp;lt;Foundation/Foundation.h&amp;gt;@interface Machine : NSObject@property (strong, nonatomic) id serialNumber;- (void) summary;@end// Machine.m#import &amp;lt;Foundation/Foundation.h&amp;gt;#import &quot;Machine.h&quot;@implementation Machine- (void) summary { NSLog(@&quot;Initializing Machine&quot;); NSString *label1 = @&quot;label1&quot;; NSString *label2 = nil; NSString *label3 = [NSNull null]; NSString *label4 = Nil; NSString *label5 = NULL; NSLog(@&quot;Label1 = %@&quot;,label1); NSLog(@&quot;Label2 = %@&quot;,label2); NSLog(@&quot;Label3 = %@&quot;,label3); NSLog(@&quot;Label4 = %@&quot;,label4); NSLog(@&quot;Label5 = %@&quot;,label5);}@endIn Swift, you can interact with this Objective-C code as follows:let OC_Machine = Machine()OC_Machine.summary()OC_Machine.serialNumber = 21OC_Machine.serialNumber = nilOC_Machine.serialNumber = NSNull()//OC_Machine.serialNumber = Nil//OC_Machine.serialNumber = NULLprint(OC_Machine.serialNumber)The commented lines will not compile in Swift because Swift does not support the use of Nil and NULL in the same way Objective-C does. The output of the above code will be:Label1 = label1 Label2 = (null) Label3 = &amp;lt;null&amp;gt; Label4 = (null) Label5 = (null) Optional(&amp;lt;null&amp;gt;) This example highlights the importance of understanding how each language treats ‚Äúnothingness‚Äù and how these concepts map between Objective-C and Swift.Summary of Key Points NULL is used for non-object pointers in C and Objective-C. It represents a null pointer in a generic sense, applicable to various data types. nil is used for object pointers in Objective-C, specifically indicating that an object does not exist. Nil is used for class pointers in Objective-C, representing the absence of a class. NSNull is a singleton object used to represent null values in collections where nil is not allowed.In Swift, nil is a fundamental part of the language‚Äôs type system and is used to indicate the absence of a value. Unlike Objective-C, where nil is a pointer, Swift‚Äôs nil is not. Understanding these differences is essential for developers working with both languages, especially in projects that involve interoperability between Swift and Objective-C. In Objective-C, nil is a pointer to a non-existent object. In Swift, nil is the absence of a value. NULL and nil are equal to each other in Objective-C, but nil is used specifically for object pointers, while NULL is for generic pointers. [NSNull null] is an object meant to represent nil in contexts where nil is not allowed, such as in collections.By mastering these concepts, you‚Äôll be better equipped to handle memory management and interoperability challenges in both Objective-C and Swift." }, { "title" : "Understanding Swift: Differences Between Any, AnyObject, and AnyHashable", "category" : "", "tags" : " Development, iOS, Programming, Swift, Objective-C", "url" : "/swift-any-anyobject/", "date" : "November 26, 2021", "excerpt" : "When working with Swift, one of the key decisions you‚Äôll often face is how to represent data types. While specificity in defining data types is generally encouraged, Swift offers three flexible type options: Any, AnyObject, and AnyHashable. ...", "content" : "When working with Swift, one of the key decisions you‚Äôll often face is how to represent data types. While specificity in defining data types is generally encouraged, Swift offers three flexible type options: Any, AnyObject, and AnyHashable. Exploring Swift&#39;s Flexible Type System Understanding when and how to use these types is crucial for developing robust and interoperable Swift applications.Introduction to Any, AnyObject, and AnyHashableSwift is a strongly typed language, meaning that every variable, constant, or expression must have a clearly defined type. However, there are situations where the exact type might not be known until runtime, or where flexibility in type is required. This is where Any, AnyObject, and AnyHashable come into play.AnyThe Any type represents an instance of any type at all, including function types, class instances, structs, and enums. It‚Äôs the most general type in Swift, allowing you to work with values without needing to know their specific types in advance.let mixedArray: [Any] = [1, &quot;Hello&quot;, 3.14, [1, 2, 3]]In this example, mixedArray can store any combination of types, from integers to strings and arrays. This can be particularly useful in scenarios where type flexibility is essential, but it should be used sparingly due to the loss of type safety.Real-World Use Cases for Any in Swift Handling Mixed-Type Data Collections Use Any to create an array that holds various data types, which is useful for data parsing from APIs. var things: [Any] = [] things.append(0) // Int things.append(3.14) // Double things.append(&quot;Hello, World!&quot;) // String things.append((3.0, 5.0)) // Tuple Dynamic Function HandlingStore function types in a collection, allowing for dynamic function calls.let functions: [Any] = [ { (name: String) -&amp;gt; String in &quot;Hello, $$name)&quot; }, { (x: Int) -&amp;gt; Int in x * 2 }]or this detailed Exampleprotocol AnyFunction { func call(with input: Any) -&amp;gt; Any}let functions: [AnyFunction] = [ AnyFunctionWrapper { (name: String) -&amp;gt; String in &quot;Hello, \\(name)&quot; }, AnyFunctionWrapper { (x: Int) -&amp;gt; Int in x * 2 }]struct AnyFunctionWrapper: AnyFunction { private let _call: (Any) -&amp;gt; Any init&amp;lt;T, R&amp;gt;(_ function: @escaping (T) -&amp;gt; R) { _call = { input in if let typedInput = input as? T { return function(typedInput) } return &quot;Invalid input type&quot; } } func call(with input: Any) -&amp;gt; Any { return _call(input) }}let greetingResult = functions[0].call(with: &quot;Alice&quot;)print(greetingResult) // Output: Hello, Alicelet doublingResult = functions[1].call(with: 5)print(doublingResult) // Output: 10let invalidResult = functions[0].call(with: 42)print(invalidResult) // Output: Invalid input type Interfacing with Objective-C APIsUse Any to handle untyped objects returned by Objective-C methods, facilitating seamless interaction. Generic ProgrammingAccept or return any type in generic programming, simplifying function signatures when specific types are not essential. Temporary Data StructuresBuild temporary data structures for algorithms, allowing storage of various types without creating multiple collections. Caution in Usage: While Any offers flexibility, it can lead to loss of type safety and increased complexity. Use more specific types whenever possible to maintain clarity and safety in your codebase.AnyObjectAnyObject is a protocol that all class types implicitly conform to. It‚Äôs used when you need to work specifically with instances of classes rather than value types like structs or enums. AnyObject is commonly used in scenarios where Swift interacts with Objective-C, especially because Objective-C types are generally class-based.let objectArray: [AnyObject] = [NSString(string: &quot;Hello&quot;), NSNumber(value: 42)]Here, objectArray holds instances that are guaranteed to be class types. This makes AnyObject a safer option when you‚Äôre dealing with class instances, especially in mixed-language projects involving both Swift and Objective-C.Real-World Use Cases for AnyObject in SwiftAnyObject allows you to work with instances of any class type. Here are some real-world scenarios where it can be beneficial: Interacting with Objective-C APIs Use AnyObject to handle untyped objects from Objective-C methods and properties, facilitating seamless interaction with these APIs. Parsing Mixed-Type JSON Data Store parsed JSON data containing a mix of types (strings, numbers, booleans) in a flexible way using AnyObject. Creating Heterogeneous Collections Create arrays or dictionaries that hold instances of different class types, allowing for storage of diverse objects together. Bridging Objective-C Classes to Swift Use AnyObject for properties, method parameters, and return values when bridging Objective-C classes, enabling interaction without knowing specific types. Implementing Dynamic Behavior Leverage AnyObject to call any Objective-C method, creating flexible and extensible APIs. Note: While AnyObject is useful, it‚Äôs important to prioritize type safety and performance by using more specific types whenever possible.AnyHashableAnyHashable is a type in Swift that allows you to store values of different types that conform to the Hashable protocol in a single collection. This is particularly useful when you need a heterogeneous collection of hashable types, such as when using a dictionary or a set.Key Features Type Erasure: AnyHashable provides a way to erase the specific type of a hashable value while still maintaining its hashability. Interoperability: It can be used in collections like Set or Dictionary where the key types might differ.Example UsageHere‚Äôs a simple example demonstrating how to use AnyHashable:let intKey: AnyHashable = AnyHashable(42)let stringKey: AnyHashable = AnyHashable(&quot;Hello&quot;)let dictionary: [AnyHashable: String] = [ intKey: &quot;This is an integer key&quot;, stringKey: &quot;This is a string key&quot;]for (key, value) in dictionary { print(&quot;\\(key): \\(value)&quot;)}The Difference Between Any and AnyObject in SwiftAny and AnyObject are two special types in Swift used for type erasure, allowing you to work with values of unknown or mixed types. Here are the key differences:Any Represents any type, including value types (structs, enums) and reference types (classes). Can be used to store heterogeneous collections of values. Example usage: let mixedArray: [Any] = [1, &quot;Hello&quot;, true, 2.0]for item in mixedArray { switch item { case let x as Int: print(&quot;Int: \\(x)&quot;) case let x as String: print(&quot;String: \\(x)&quot;) case let x as Bool: print(&quot;Bool: \\(x)&quot;) case let x as Double: print(&quot;Double: \\(x)&quot;) default: print(&quot;Unknown type&quot;) }} AnyObjectRepresents any instance of a class, equivalent to id in Objective-C.Only allows reference types (classes) and is useful when you specifically want to work with class instances.Example usage:class Car {}class Song {}let objectsArray: [AnyObject] = [Car(), Car(), Song()]for item in objectsArray { if let car = item as? Car { print(&quot;Car: $$car)&quot;) } else if let song = item as? Song { print(&quot;Song: $$song)&quot;) } else { print(&quot;Unknown type&quot;) }}When to Use Any vs. AnyObject Use Any: When your collection or variable needs to handle multiple types, including value types like Int, String, and Array. When your data will be used exclusively in Swift code, allowing you to include both value and reference types. Use AnyObject: When dealing with APIs that expect class types, such as when interfacing with Objective-C code. When you specifically need to work with reference types. When your data will interact with Objective-C code or when you specifically need to constrain your data to class types. AnyHashableAs mentioned earlier, AnyHashable is a type-erased wrapper that can hold any value conforming to the Hashable protocol. It allows you to store heterogeneously-typed values in collections that require a hashable type, such as sets or dictionaries.import Foundationlet anyHashableDict: [AnyHashable: Any] = [ &quot;key1&quot;: &quot;value1&quot;, 42: &quot;value2&quot;, UUID(): &quot;value3&quot;]print(anyHashableDict)In this example, anyHashableDict can have keys of different types, as long as those types conform to the Hashable protocol. AnyHashable is particularly useful when dealing with untyped sets or dictionaries coming from Objective-C, as it provides the necessary flexibility while maintaining type safety within Swift.ConclusionUnderstanding when to use Any, AnyObject, and AnyHashable can greatly enhance your flexibility and interoperability in Swift development. While these types provide powerful tools for working with a wide range of data, it‚Äôs important to use them judiciously to maintain the clarity and safety of your code. By carefully choosing the appropriate type based on the needs of your application, you can ensure that your Swift code is both robust and adaptable." }, { "title" : "Swift Root/Base Class &amp; NSObject: A Quick Look", "category" : "", "tags" : " Development, iOS, Programming, Swift", "url" : "/swift-root-class-nsobject/", "date" : "November 16, 2021", "excerpt" : "In the world of object-oriented programming (OOP), the concept of a root or base class is foundational for understanding class inheritance and the relationships between different classes.Whether you‚Äôre building an app in Swift or working with lega...", "content" : "In the world of object-oriented programming (OOP), the concept of a root or base class is foundational for understanding class inheritance and the relationships between different classes.Whether you‚Äôre building an app in Swift or working with legacy Objective-C code, grasping the role of the root class is key to designing robust, scalable software. In this post, we‚Äôll dive deep into the role of the root class in Swift and its relationship with NSObject within the context of Objective-C and Cocoa frameworks. Understanding the Concept of a Root ClassIn object-oriented programming, a root class, also known as a base class, is the topmost class in an inheritance hierarchy. It acts as the foundation upon which all other classes are built. Essentially, all subclasses inherit the properties and methods of the root class, making it a critical element in the design of any object-oriented system.Key Characteristics of a Root Class: Inheritance: A root class provides default implementations for properties and methods that can be inherited and potentially overridden by subclasses. Polymorphism: The root class enables polymorphic behavior, allowing subclasses to be treated as instances of the root class, enabling flexible and reusable code. Common Interface: It often defines a common interface that all subclasses adhere to, ensuring consistency across the object hierarchy.Root Class in Objective-C and CocoaIn Objective-C the de facto root class for nearly all objects within the Cocoa and Cocoa Touch frameworks is NSObject, a part of the Foundation framework. This means that virtually every class in these frameworks ultimately derives from NSObject, either directly or indirectly.NSObject in DetailNSObject is more than just a root class; it‚Äôs the cornerstone of the entire Cocoa framework. It provides a wealth of essential methods that support basic object behavior, including: Memory Management: With methods like retain, release, and autorelease, NSObject plays a pivotal role in manual memory management under the older retain/release model, and it‚Äôs still relevant in the context of ARC (Automatic Reference Counting). Method Swizzling: NSObject facilitates powerful runtime features like method swizzling, allowing developers to dynamically change method implementations at runtime. Equality and Hashing: NSObject defines fundamental methods such as isEqual: and hash, which are crucial for comparing objects and storing them in collections like NSSet or NSDictionary. KVC &amp;amp; KVO: It also supports Key-Value Coding (KVC) and Key-Value Observing (KVO), allowing properties to be accessed and monitored dynamically at runtime.Root Class in SwiftIn Swift, when you define a class without specifying a superclass, it automatically becomes a root class, reflecting a deliberate design choice aimed at simplicity and safety. This approach is similar to Objective-C, where although NSObject is commonly used as the root class, it is not strictly enforced. Developers can create classes that do not inherit from any other class, allowing for custom root classes. For instance, Apple‚Äôs API includes multiple root classes, such as NSObject, NSProxy, and the now-deprecated Object.The historical reason for having a root class, particularly in Objective-C, was to ensure that all objects shared a common interface, including essential methods like isEqualTo:, hash(), and others required for collection classes. However, with the advent of generics in Swift, the necessity of a root class has diminished.In Swift, many of the methods traditionally provided by NSObject have been distributed across protocols such as Equatable, Hashable, and CustomStringConvertible, which allows both classes and structs to share common interfaces. This approach enhances Swift‚Äôs flexibility and aligns with its protocol-oriented nature.Although a universal root class is not necessary in pure Swift, you can still inherit from NSObject when working with Objective-C APIs, ensuring smooth interoperability. It‚Äôs also important to understand that Swift classes do not run on top of Objective-C; they are compiled by the same compiler, which allows for seamless interoperation between Swift and Objective-C when needed. This is why the @objc attribute is sometimes required to ensure consistency with Objective-C protocols and classes.Swift‚Äôs Flexibility and InteroperabilitySwift does not have a universal base class that all classes inherit from by default. However, it is still designed to interoperate seamlessly with Objective-C, allowing developers to leverage existing Cocoa frameworks. This interoperability is facilitated through: @objc Attribute: This attribute marks Swift classes, methods, and properties to be compatible with Objective-C, enabling them to be exposed to and used by Objective-C code. This ensures that Swift and Objective-C can coexist within the same project, allowing for mixed-language development. NSObject: While not required, Swift classes can inherit from NSObject to gain access to Objective-C runtime features. This is particularly useful when working with Cocoa APIs that rely on dynamic features such as KVO (Key-Value Observing) or when a class needs to be compatible with Objective-C‚Äôs expectations, such as when it needs to be part of an Objective-C collection or needs to respond to selectors.Practical ImplicationsWhen working within a mixed Swift/Objective-C codebase, understanding when and why to subclass NSObject is critical. For example: Interfacing with Cocoa Frameworks: If your Swift class needs to interact with Cocoa frameworks that rely on Objective-C runtime features, subclassing NSObject may be necessary. Using KVO: If you plan to use Key-Value Observing, your Swift class must inherit from NSObject because KVO is deeply tied to the Objective-C runtime.ConclusionUnderstanding the role of root classes is essential for developers working with object-oriented languages like Swift and Objective-C. In Objective-C, NSObject serves as a commonly used root class, providing a rich set of functionalities that underpin the Cocoa frameworks. However, Objective-C does not enforce a universal base class, allowing for the creation of custom root classes.In contrast, Swift does not have a universal base class, offering more flexibility. Swift classes can stand alone without inheriting from any superclass, or they can inherit from NSObject when interoperability with Objective-C is required.Mastering the nuances of root classes in both languages can lead to more effective, maintainable, and scalable code. Whether you‚Äôre building new applications in Swift or maintaining legacy Objective-C code, a deep understanding of these concepts will serve as a powerful tool in your development arsenal." }, { "title" : "Swift&#39;s Basic Data Types &amp; Type Inference", "category" : "", "tags" : " Development, iOS, Programming, Swift", "url" : "/swift-built-in-data-types/", "date" : "November 15, 2021", "excerpt" : "Swift offers a variety of built-in data types that cater to different kinds of data. Understanding these types is essential for writing efficient and bug-free code. Swift‚Äôs Basic Data TypesBelow is an overview of the primary data types av...", "content" : "Swift offers a variety of built-in data types that cater to different kinds of data. Understanding these types is essential for writing efficient and bug-free code. Swift‚Äôs Basic Data TypesBelow is an overview of the primary data types available in Swift: Type Description Character Represents a single 16-bit Unicode character, like &quot;a&quot; or &quot;/&quot;. String Represents a sequence of characters, used for textual data like &quot;Hello&quot;. Float A 32-bit floating-point number, useful for representing fractional values. Double A 64-bit floating-point number, offering double the precision of a Float. Bool Represents a Boolean value, which can be either true or false. Tuples Groups multiple values into a single compound value, e.g., (1, &quot;Hello&quot;). Int Represents a signed integer (whole number). On 32-bit platforms, it is Int32; on 64-bit platforms, it is Int64. UInt Represents an unsigned integer (whole number). On 32-bit platforms, it is UInt32; on 64-bit platforms, it is UInt64. Int8 A signed 8-bit integer, capable of storing values from -128 to 127. Int32 A signed 32-bit integer, common in many programming tasks. Int64 A signed 64-bit integer, offering a wider range of values. UInt8 An unsigned 8-bit integer, with a range of 0 to 255. UInt32 An unsigned 32-bit integer, often used in systems programming. UInt64 An unsigned 64-bit integer, useful for representing large positive integers. Device-Specific Integer SizesOn 32-bit devices, the Int type has the size of Int32, while on 64-bit devices, it has the size of Int64. The same principle applies to UInt, where its size depends on the architecture of the device.Type Inference in SwiftOne of Swift‚Äôs powerful features is type inference, which allows the compiler to automatically determine the type of a variable based on the value assigned to it. This can significantly reduce the amount of boilerplate code and make the code more readable.Example of Type InferenceConsider the following example, where the type of the variable level is inferred by Swift:var level = 12Here, Swift automatically infers that level is of type Int because 12 is an integer. The compiler‚Äôs ability to infer types simplifies the code, especially in cases where the type is obvious from the context.Explicit Type AnnotationWhile type inference is a valuable feature, there are scenarios where explicitly specifying the type is beneficial or even necessary. For instance, when dealing with complex data structures or when the inferred type may not be immediately clear to someone reading your code, explicit type annotations enhance readability and maintainability.var level: Int = 17In this case, even though the type could be inferred, declaring it explicitly as Int improves clarity, particularly in larger codebases where understanding the intent behind each variable is crucial.The Impact of Type Inference on PerformanceType inference in Swift, while primarily aimed at improving code readability and reducing boilerplate, also has implications for performance. The Swift compiler is designed to be highly efficient, and type inference plays a role in this efficiency. However, understanding when and how type inference affects performance can help developers make informed decisions in critical parts of their code.Compilation PerformanceOne area where type inference can impact performance is during the compilation process. When Swift infers types, the compiler has to analyze the code more extensively to deduce the correct types, which can slightly increase compilation times, especially in large codebases with complex type relationships. While this overhead is generally minimal, it can become noticeable in very large projects or in code that makes heavy use of generic types and protocols.Runtime PerformanceAt runtime, Swift‚Äôs type inference has little to no impact on the performance of the compiled code. The inferred types are determined at compile time, meaning that by the time your application is running, the types are already fixed and optimized by the compiler. This ensures that the performance of your application is consistent, regardless of whether types were inferred or explicitly declared.Best Practices for PerformanceTo optimize both compile-time and runtime performance, consider the following best practices: Explicit Type Annotations in Complex Expressions: In scenarios where complex expressions are used, explicitly annotating types can help the compiler optimize the code more effectively, reducing compilation time. Avoid Overuse of Type Inference in Critical Paths: In performance-critical code, such as in tight loops or algorithms, explicit types can sometimes lead to more predictable and optimized compiled code. Balance Readability and Performance: While type inference makes code more concise, always balance this with the need for clarity and performance. In complex or critical sections of your code, it might be beneficial to favor explicit type declarations.By being mindful of when and where to rely on type inference, you can write Swift code that is both efficient and maintainable, ensuring that your applications perform optimally without sacrificing code quality.Unsafe Types in SwiftIn addition to the safe and type-safe data types that Swift provides, there are also ‚Äúunsafe‚Äù types that allow developers to work with memory directly. These types are primarily used in scenarios where performance is critical, or when interfacing with lower-level APIs, such as C libraries. While they offer greater flexibility and control, they come with increased risks, as they bypass Swift‚Äôs safety features.1. UnsafePointerUnsafePointer is a type that provides a pointer to a memory location. It allows you to read values from memory without the safety guarantees that Swift typically enforces. Here‚Äôs an example of how to use UnsafePointer:let numbers: [Int] = [1, 2, 3, 4, 5]let pointer = UnsafePointer(numbers)print(pointer[0]) // Access the first element2. UnsafeMutablePointerUnsafeMutablePointer allows both reading and writing of values at a specific memory location. This is useful when you need to modify the contents of an array or a buffer directly:var mutableNumbers: [Int] = [1, 2, 3, 4, 5]let mutablePointer = UnsafeMutablePointer(&amp;amp;mutableNumbers)mutablePointer[0] = 10 // Change the first element to 10print(mutableNumbers) // Output: [10, 2, 3, 4, 5]3. UnsafeRawPointerUnsafeRawPointer is a pointer that points to raw memory without any type information. This can be useful for low-level operations, such as when working with binary data or interfacing with C APIs:var mutableNumbers: [Int] = [1, 2, 3, 4, 5]let mutablePointer = UnsafeMutablePointer(&amp;amp;mutableNumbers)let rawPointer = UnsafeRawPointer(mutablePointer)let intPointer = rawPointer.assumingMemoryBound(to: Int.self)print(intPointer[0]) // Access the first element as an IntCGFloat: A Special CaseA noteworthy data type in Swift is CGFloat, which is particularly relevant when dealing with graphical calculations in iOS and macOS applications. CGFloat can represent either a 32-bit or 64-bit floating-point number, depending on the device‚Äôs CPU architecture. This makes it a versatile choice for applications that require precise and scalable graphical calculations, such as in drawing operations or animations.Understanding Swift‚Äôs data types and effectively using type inference can lead to more concise, readable, and safer code. By mastering these fundamentals, you can write Swift code that is not only efficient but also easy to maintain and extend as your projects grow." }, { "title" : "Understanding Swift Variables and Constants: A Dive into Mutability", "category" : "", "tags" : " Development, iOS, Programming, Swift, Objective-C", "url" : "/swift-variables-and-constants/", "date" : "November 14, 2021", "excerpt" : "In every programming language, the ability to store and manage data is fundamental. In Swift, the distinction between variables and constants is both clear and essential, influencing how you write and optimize your code. This blog post explores th...", "content" : "In every programming language, the ability to store and manage data is fundamental. In Swift, the distinction between variables and constants is both clear and essential, influencing how you write and optimize your code. This blog post explores the concepts of mutability in Swift, comparing them to Objective-C, and discussing the broader implications of mutability in programming. The Power of Mutability in Swift Swift Variables and Constants: The BasicsIn Swift, the way you store data hinges on two keywords: let for constants and var for variables. This distinction is not just syntactical but plays a critical role in ensuring the safety, performance, and clarity of your code.For example, consider a Customer class in Swift:class Customer { let id = 22034 let birthdate = &quot;11/11/2011&quot; var balance = 109.3}Constants cannot change after you run your app, they prevent accidental breakage of a value that should not change.In this example: id and birthdate are constants (let), meaning once they are set, they cannot be changed. balance is a variable (var), meaning it can be modified after its initial assignment.Why Use Constants?Constants in Swift are more than just a way to store unchangeable data. They offer several advantages: Safety: By marking a value as constant, you prevent accidental modifications, which can lead to bugs and unintended behavior in your program. Performance: Constants can be optimized by the compiler for better performance. Since their values don‚Äôt change, the compiler can make assumptions that lead to faster code execution.Mutability in Objective-C vs. SwiftSwift‚Äôs clear distinction between let and var is a marked improvement over Objective-C, where mutability is less explicit. In Objective-C, immutability is often enforced through class hierarchies (e.g., NSString vs. NSMutableString) rather than syntax. This can lead to confusion, as the mutability of an object isn‚Äôt always immediately apparent from its declaration.NSString *constName = @&quot;John&quot;;NSMutableString *mutableName = [NSMutableString stringWithString:@&quot;John&quot;];In the above Objective-C example: constName is a constant pointer to an immutable NSString object. mutableName is a pointer to a mutable NSMutableString object.Swift, by contrast, makes mutability explicit with let and var. This clarity reduces the cognitive load on the developer, making the code easier to read, understand, and maintain.The Broader Implications of MutabilityMutability is a key concept not just in Swift, but in programming in general. When designing systems, deciding whether an object should be mutable or immutable has far-reaching consequences: Concurrency: Immutable objects are naturally thread-safe, as their state cannot change after they are created. This makes them ideal for concurrent programming. Design Patterns: Many design patterns, such as the Builder pattern, rely on mutability during object construction and immutability afterward. Predictability: Immutable objects lead to more predictable and less error-prone code since their state cannot change unexpectedly.In Swift, leveraging constants wherever possible can lead to more robust and maintainable code. By defaulting to let and only using var when necessary, you reduce the potential for bugs and make your intentions clear to others reading your code.Conclusion:Understanding and utilizing Swift‚Äôs approach to variables and constants is crucial for writing clean, efficient, and reliable code. By explicitly defining mutability with let and var, Swift encourages best practices and helps you avoid common pitfalls that can occur in languages with less clear mutability rules.Whether you‚Äôre transitioning from Objective-C or just starting with Swift, embracing these concepts will elevate the quality of your code and make your applications more robust. Remember, in Swift, clarity is key‚Äîso let your constants be constants and your variables be variables, and your code will thank you for it." }, { "title" : "Mastering Swift Style Guides: Elevate Your Code to the Next Level", "category" : "", "tags" : " Development, Programming, Swift", "url" : "/swift-style-guides/", "date" : "November 10, 2021", "excerpt" : "Have you ever dived into an open-source project and marveled at the elegance and consistency of the codebase? üßê It‚Äôs no coincidence.Such codebases follow meticulously crafted style guides that turn good code into great code. But let‚Äôs face it‚Äîmany...", "content" : "Have you ever dived into an open-source project and marveled at the elegance and consistency of the codebase? üßê It‚Äôs no coincidence.Such codebases follow meticulously crafted style guides that turn good code into great code. But let‚Äôs face it‚Äîmany of us have also encountered the other side of the spectrum: projects that are chaotic, messy, and downright painful to navigate ü§Æ.What‚Äôs the difference? It often boils down to one crucial element: the presence‚Äîor absence‚Äîof a robust code style guide. Crafting Consistency with Swift Style Guides The Importance of Code Style GuidesIn the vibrant world of Swift programming, various style guides have emerged, each offering its own take on how to write clean, efficient, and maintainable code. Some of the most influential guides come from industry giants like Apple, Google, Ray Wenderlich, LinkedIn, and Airbnb.Each guide brings its own flavor, but they all share a common goal: to help developers write better code.Choosing the Right Guide for Your ProjectChoosing a code style guide isn‚Äôt just about personal preference; it‚Äôs about aligning the guide with the specific needs of your project. Whether you‚Äôre building a high-performance app or a user-friendly interface, the right style guide can make all the difference. Take the time to explore these guides‚Äîdelve into the nuances of each, and you‚Äôll find one that resonates with your development style and project goals.Why Consistency MattersBut why does it matter so much? As developers, we spend far more time reading code than writing it üòå. A well-maintained code style isn‚Äôt just a nicety‚Äîit‚Äôs an investment in the future of your project. Consistency in code styling makes it easier for you and your team to understand, maintain, and extend the codebase. Proper indentation, consistent naming conventions, and thoughtful spacing aren‚Äôt just cosmetic‚Äîthey‚Äôre the foundation of maintainable software that stands the test of time. And let‚Äôs not forget the collaborative benefits: clean code fosters better teamwork and smoother code reviews üòá.Beyond the Basics: Expanding Your Style Guide HorizonsApple‚Äôs API Design Guidelines provide an excellent starting point, especially when it comes to naming conventions. However, while Apple‚Äôs guidelines are indispensable, they don‚Äôt cover every aspect of Swift coding practices. That‚Äôs where additional resources come in.For those looking to go above and beyond, I highly recommend exploring the Ultimate Swift Code Style Guidelines by Nikita Lazarev-Zubov.Nikita offers a comprehensive, well-thought-out guide that not only adheres to best practices but also challenges them where necessary. Her insights can provide you with the tools to refine your coding style and ensure your codebase is as polished and professional as possible.Conclusion: Elevating Your Code to the Next LevelMastering Swift style guides is more than just following a set of rules‚Äîit‚Äôs about elevating your code and contributing to a culture of excellence in software development. So, choose your style guide wisely, and watch your code‚Äîand your projects‚Äîflourish." }, { "title" : "Swift Lexical Structure", "category" : "", "tags" : " Development, Programming, Swift, Syntax", "url" : "/swift-lexical-structure/", "date" : "November 1, 2021", "excerpt" : "The Swift lexical structure consists of valid tokens (the lowest-level building blocks) that form the structure of any Swift program. These tokens describe the entirety of the Swift language.A token consists of an identifier, keyword, punctuation,...", "content" : "The Swift lexical structure consists of valid tokens (the lowest-level building blocks) that form the structure of any Swift program. These tokens describe the entirety of the Swift language.A token consists of an identifier, keyword, punctuation, literal, or operator. Swift Lexical StructureIdentifiers**An example of an identifier is a variable name, for example here ‚Äúpet‚Äù is an identifier.let pet = &quot;Happy Dinosaur ü¶ñ&quot;Identifiers support unicode characters, you can name you variable in you native language, and as in other programming languages, you cannot use keywords as identifiers, this is still possible if you surrounding a keyword with back-ticks,var `var` = &quot;var&quot;examples of unicode identifiers arevar _latitude = 32.0var „Ç¢„ÉÉ„Éó„É´ = &quot;apple&quot;The list of basic keywords in Swift is shown below. For a comprehensive list and details, see the Swift Reserved Keywords. Keywords Keywords Keywords class deinit enum extension func import init let protocol static struct subscript typealias var break continue default do else fallthrough if in for return switch where while as dynamicType is new super self Self Type __COLUMN__ __FILE__ __FUNCTION__ __LINE__ associativity didSet get infix inout left mutating none nonmutating override precedence prefix right set unowned unowned(safe) unowned(unsafe) weak willSet ¬† ¬† LiteralsLiterals in Swift fall into three categories: integer literals, floating-point literals, and string literals.Integer Literalsvar a = 10 var b = 00010100b //Binaryvar c = 14x //Hexadecimalvar d = 24o //Octal leading zeros will be ignored by the compiler, and the use of underscores is possible to increase readability.var a = 100_000_000Floating Point Literalsvar a = 10.7 //Simple floating point number var b = 10.6e2 //Exponent floating point number var c = 10.1e-2 //Exponent floating point number var d = 0xAp2 //Hexa decimal exponent var d = 0xAp-2 //Hexa decimal exponent String LiteralsString literals are characters are enclosed within double quotes. Strings can contain escape sequences to represent characters like qoutes.Example for string literal is shown below:var a = &quot;test&quot; var a = &quot;Hello\\\\nWorld&quot;Common escape sequences include: Escape Sequence Description \\\\0 Null Character \\\\ Backslash \\\\t Horizontal Tab \\\\n New Line \\\\r Carriage Return \\\\&quot; Double Quote \\\\&#39; Single Quote Operators:Swift supports various operators, including: Operator Description + Addition - Subtraction * Multiplication / Division % Remainder ^ Exponent &amp;amp; Bitwise And &amp;amp;&amp;amp; Logical And | Bitwise Or || Logical Or ++ Increment Operator -- Decrement Operator ~ Bitwise Not &amp;lt; Less Than &amp;gt; Greater Than ... Etc. Remember, some punctuation is reserved in Swift and cannot be used as custom operators: Punctuation Restrictions (, ) Cannot be used as custom operators {, } Cannot be used as custom operators [, ] Cannot be used as custom operators ., , Cannot be used as custom operators :, ; Cannot be used as custom operators = Cannot be used as custom operators @, # Cannot be used as custom operators &amp;amp; Cannot be used as a prefix operator -&amp;gt; Cannot be used as custom operators ` Cannot be used as custom operators ?, ! Cannot be used as postfix operators Swift WhitespaceWhitespace in Swift plays a crucial role in improving code readability and structure. It is primarily used to separate tokens, ensuring that the syntax is clear and unambiguous. While whitespace can be freely used to format your code for better legibility, it is generally ignored by the Swift compiler unless it serves a syntactic purpose, such as distinguishing between prefixes or separating keywords and identifiers.Swift CommentsComments in Swift are essential for making your code more understandable to others (and yourself in the future). They are completely ignored by the compiler and serve purely for documentation purposes. Swift supports both single-line and multi-line comments, allowing you to annotate your code as needed:// This is a single line comment/* Multi line (block) comment - can havemore than one line! */" }, { "title" : "Swift Reserved Keywords, with brief explanations.", "category" : "", "tags" : " Development, Programming, Swift", "url" : "/swift-keywords/", "date" : "November 1, 2021", "excerpt" : "A reserved word is a term designated by the programming language that cannot be used as an identifier. This restriction is a syntactic rule that helps prevent conflicts and ambiguities in the code. As detailed in Swift Lexical Structure, ...", "content" : "A reserved word is a term designated by the programming language that cannot be used as an identifier. This restriction is a syntactic rule that helps prevent conflicts and ambiguities in the code. As detailed in Swift Lexical Structure, these reserved words are integral to the language‚Äôs syntax and functionality. For convenience, all lists of reserved words provided below are arranged alphabetically, facilitating quick and easy reference.Keywords used in declarationsKeywords for defining types, methods, and essential elements in Swift, including classes, structs, enums, protocols, and properties, along with access control and initialization behavior. Reserved Word Details associatedtype Associated types are a powerful way of making protocols generic, it¬†gives a placeholder name to a type that‚Äôs used as part of the protocol. class One of swift‚Äôs general purpose, flexible constructs also see struct deinit A method that gets automatically called when an object is freed up from memory by ARC. enum Enums let‚Äôs you define a custom kind of value in Swift, with predefined possible values. extension Extensions¬†add new functionality to an existing class, structure, enumeration, or protocol type. fileprivate One of swift‚Äôs access modifiers. func Used for creating functions. import A declaration used for importing modules and submodules init as per swift documentation, ‚ÄúInitialization¬†is the process of preparing an instance of a class, structure, or enumeration for use.‚Äù inout inout allows parameters to be changed outside of the function scope. internal One of swift‚Äôs access modifiers. let A keyword used for declaring a constant open One of swift‚Äôs access modifiers. operator A special symbol/ phrase that you use to check, change, or combine values. private One of swift‚Äôs access modifiers. precedencegroup defining precedence groups to use for our custom operators. protocol as per swift‚Äôs official documentation ‚ÄúA¬†protocol¬†defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality.‚Äù public One of swift‚Äôs access modifiers. rethrows rethrows keyword is used with function that accepts a throwing function as a parameter. static defines a static scope. struct complex value-types. subscript Subscripts allow you to write shortcuts to elements from collections, Sequences in classes, structures and enumerations. typealias Defines an alias for an existing type. var A keyword used for declaring a variable. Keywords used in statementsKeywords that control the flow of execution in Swift, managing loops, conditionals, error handling, and control transfer within code blocks. Reserved Word Details break One of the control transfer statements, ends execution of a loop, an if statement, or a switch statement. case Used for pattern testing. catch Used for handling any potential errors caused by a function that throws. continue One of the control transfer statements, ends execution of the current iteration of a loop statement but does not stop execution of the loop statement. default Used for default cases in switch. defer Used for making a block to execute just before a function exits. do Used for creating do blocks, for example (do-while, do-catch) else Used for executing a block when a condition is not satisfied. fallthrough One of the control transfer statements for Used for iterating over a sequence. guard Used in control transfer statement and optional unwrapping. if Used for condition evaluation. in In is a keyword defined in the Swift closure syntax as a separator between the function type and the function body in a closure, and used in checking if an object is in a sequence. repeat A control flow statement, similar to while loop return One of the control transfer statements throw Used for throwing an error in a function that throws. switch A switch statement considers a value and compares it against several possible matching patterns. where Used to filter out values, in statements like switch, for, protocol extension, first, contains, initializers. while A control flow statement, it performs a set of statements until a condition becomes false Keywords used in expressions and typesKeywords for type casting, handling optional values, and managing Boolean literals, aiding in type checking and error handling. Reserved Word Details Any Any can represent an instance of any type at all, including function types. as Used for type casting. catch Used in error handling, when an error is thrown, it‚Äôs matched against the catch clauses. false A literal used to express booleans. is Used to check whether an object is of a certain class type nil A valueless state that could be assigned to optionals. rethrows allows forwarding a thrown error by a given function parameter self ‚Äúself‚Äù refers to the current object within a class or struct. Self Refers to a type ‚Äì usually the current type in the current context. super super is used to call up to your superclass. throw Used for throwing an error in a function that throws. throws To mark a function throwing. true A literal used to express booleans. try The try keyword is used to indicate that a method can throw an error. To catch and handle an error, the throwing method call needs to be wrapped in a do-catch statement. Keywords used in patternsKeywords for pattern matching and destructuring values, used in control flow statements and variable assignments. Reserved Word \\_ . Keywords that begin with a number sign (#), literals expressionsCompile-time literals and directives providing information about the source code, such as file names and line numbers, and controlling runtime behavior. Reserved Word Details #available Used to determine the availability of APIs at runtime #colorLiteral Used to make the XCode IDE to display a color swatch üü• #column column number of the line where it is being run. #dsohandle Represents the dynamic shared object handle, which is used in low-level programming contexts, particularly when dealing with dynamic libraries. It is not commonly used in everyday Swift development. #elseif Literal conditional statement #else Literal else statement. #endif Literal marker for closing an a literal if statement #error Creates a red compiler error &amp;amp; prevents code from compiling #fileID Generates concise file string in all language modes. #fileLiteral Used to make the XCode IDE link to a local file. #filePath Outputs the file path of in which code is being run. #file Outputs the name of the file in which code is being run. #function Outputs the name of the function where code belongs. #if Literal if statement. #imageLiteral Used to make the XCode IDE to display an image. #keyPath Used to refer to properties in a type-safe manner, allowing for dynamic key paths in Swift. This is particularly useful in conjunction with KVO (Key-Value Observing) and other reactive programming paradigms. #line line number where it is being run. #selector Used to refer to a method that can be called by Objective-C runtime. This is essential for methods that are intended to be used as selectors in target-action patterns or notifications. #sourceLocation Allows developers to specify the source location for logging purposes, which can be helpful in tracing back to the original source of a log message. This can be particularly useful in large projects. #warning will cause Xcode to display a warning with the given message.¬† Keywords reserved in particular contextsKeywords with specific meanings in certain contexts, such as defining operator behaviors, property observers, and type properties. Reserved Word Details associativity defines how operators of the same precedence are grouped together. convenience Convenience modifier placed before the init keyword. didSet A property observer dynamic A declaration modifier used to make use of Objective-C‚Äôs dynamism. final One of Swift‚Äôs access modifiers. get Used when getting a computed property. indirect Used for recursive Enums infix Used when creating custom operators. lazy Used for just-in-time calculation. left Used to specify the associativity of a custom operator mutating Functions marked as mutating can change any property within its enclosing value none Used to specify the associativity of a custom operator nonmutating Indicates that a method does not modify the instance it belongs to. This is important for maintaining immutability in certain contexts. optional Indicates that a value may be absent, allowing for the representation of the absence of a value in a type-safe manner. This is a core feature of Swift‚Äôs type system. override Used for overriding child classes. postfix Used in creating custom functions, it‚Äôs mathematical notation in which operators follow operands. precedence Operator precedence is a set of rules that determine which operator is executed before another. prefix Used in creating custom functions, it‚Äôs mathematical notation in which operators follow operands. Protocol A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. required Required keyword means that inheriting classes must provide an implementation of the method. right Used to specify the associativity of a custom operator set Used when getting a computed property. some denotes an opaque type. Type A metatype type refers to the type of any type, including class types, structure types, enumeration types, and protocol types. unowned A reference type, used for memory management. weak A reference type, used for memory management. willSet A property observer Outside the context in which they appear in the grammar, they can be used as identifiers.The following tokens are reserved as punctuation and can‚Äôt be used as custom operators:¬†(,&amp;nbsp;){,&amp;nbsp;}&amp;nbsp;[,&amp;nbsp;]&amp;nbsp;.,:;=@#&amp;amp;&amp;nbsp;(as a prefix operator)-&amp;gt;`?!&amp;nbsp;(as a postfix operator)Bitwise Operators in SwiftOperators for performing bit-level operations on integers, useful for low-level programming and efficient data manipulation. Operator Description &amp;amp; (Bitwise AND): Performs a bitwise AND operation between two integers. Each bit in the result is set to 1 if the corresponding bits of both operands are 1. | (Bitwise OR): Performs a bitwise OR operation between two integers. Each bit in the result is set to 1 if at least one of the corresponding bits of either operand is 1. ^ (Bitwise XOR): Performs a bitwise XOR operation between two integers. Each bit in the result is set to 1 if the corresponding bits of the operands are different. ~ (Bitwise NOT): Performs a bitwise NOT operation on a single integer. This operator inverts all the bits of the operand, turning 0s into 1s and 1s into 0s. &amp;lt;&amp;lt; (Left Shift): Shifts the bits of an integer to the left by a specified number of positions. This operation effectively multiplies the integer by 2 for each position shifted. &amp;gt;&amp;gt; (Right Shift): Shifts the bits of an integer to the right by a specified number of positions. This operation effectively divides the integer by 2 for each position shifted. &amp;amp;= (Bitwise AND Assignment): Combines the bitwise AND operation with assignment. It updates the variable by performing a bitwise AND between its current value and another value. |= (Bitwise OR Assignment): Combines the bitwise OR operation with assignment. It updates the variable by performing a bitwise OR between its current value and another value. ^= (Bitwise XOR Assignment): Combines the bitwise XOR operation with assignment. It updates the variable by performing a bitwise XOR between its current value and another value. These operators are applied to integer types (Int, UInt, etc.) and provide a way to perform efficient, low-level bit manipulation in Swift. They are especially useful in scenarios where performance and direct hardware interaction are critical." }, { "title" : "Advantages of Swift Over Objective-C", "category" : "", "tags" : " Development, iOS, Programming, Swift, Objective-C", "url" : "/swift-pros-over-obj-c/", "date" : "October 18, 2021", "excerpt" : "Objective-C, developed in the early 1980s, has long been the backbone of iOS and macOS development. Its deep integration with Apple‚Äôs ecosystem made it a preferred choice for developers working on these platforms for decades. However, with the int...", "content" : "Objective-C, developed in the early 1980s, has long been the backbone of iOS and macOS development. Its deep integration with Apple‚Äôs ecosystem made it a preferred choice for developers working on these platforms for decades. However, with the introduction of Swift in 2014, Apple provided a modern alternative that addresses many of the limitations and complexities of Objective-C.Swift ProsSwift, designed from the ground up to be faster, safer, and more efficient, has quickly gained popularity among developers. It brings several significant improvements, including enhanced readability through a more concise and expressive syntax, superior performance optimizations that leverage modern hardware, and advanced safety features that help developers write more reliable code with fewer bugs. Swift‚Äôs design is influenced by modern programming paradigms, making it not only easier to learn for new developers but also more powerful for seasoned professionals looking to build robust and scalable applications.Moreover, Swift‚Äôs open-source nature has fostered a vibrant and growing community, contributing to its rapid evolution and adoption across various platforms beyond iOS and macOS, such as Linux and even Windows. This has expanded Swift‚Äôs appeal beyond traditional Apple developers to a broader audience, enhancing its ecosystem with a wealth of libraries, tools, and frameworks that further accelerate development and innovation. 1. Swift is Easier to Read and MaintainSwift eliminates many legacy conventions from Objective-C. For example, Swift does not require semicolons to end lines, and parentheses around conditional expressions are optional. This helps reduce the clutter of ‚Äúbracket hell‚Äù in method calls. Additionally, Swift removes the need for two separate files (header and implementation); the LLVM compiler automatically figures out dependencies.Swift also embraces modern programming language features, such as using the + operator for string concatenation and string interpolation. This approach is both easier to read and less error-prone compared to Objective-C‚Äôs use of format specifiers like %s, %d, and %@, which can often lead to crashes.2. Swift Offers Better Safety and Memory ManagementIn Objective-C, calling a method on a nil pointer does nothing, which can lead to silent failures and unexpected behavior. Swift solves this problem with optional types, allowing developers to handle the absence of a value explicitly, thus avoiding many potential bugs.Unlike Objective-C, Swift‚Äôs Automatic Reference Counting (ARC) works across both object-oriented and procedural code. This reduces the cognitive load on developers, allowing them to focus on implementing core app logic rather than managing memory manually.3. Swift is Faster and Less Prone to Name CollisionsBenchmarks have consistently shown that Swift performs faster than Objective-C, thanks to its modern architecture and optimizations. An example of a benchmark conducted by Apple. Objective-C lacked native support for namespaces, often leading to name collisions that were traditionally avoided by prefixing class names (e.g., NSArray, NSString). In Swift, namespaces are automatically determined based on the module, allowing for more flexibility and fewer conflicts. For instance, both Apple and Google frameworks could contain a file named Authentication.swift without issue.4. Swift Supports Dynamic LibrariesWhile Objective-C only supports static libraries, Swift supports dynamic libraries, which can be loaded into an app‚Äôs memory at runtime. This capability reduces the overall size of an app and allows for faster load times for new, on-demand content.5. Swift is Open-Source with a Larger CommunitySwift‚Äôs open-source nature has fostered a large and active community. It has expanded beyond Apple‚Äôs ecosystem to other environments like Linux. For example, Vapor is a popular web framework for Swift. The Swift language is developed in the open, and all technical or administrative topics about the language or community processes should be directed to the Swift public forums. Public conversations are encouraged, and active developers of the Swift language should monitor the relevant forum categories.‚Äî Swift.orgAdditional Advantages of Swift Over Objective-CSwift offers several advanced features that enhance its utility and security over Objective-C: Type Safety and Optionals: Swift enforces strict type safety, reducing the risk of type-related errors that can lead to security vulnerabilities. Its use of optionals requires developers to handle nil values explicitly, minimizing the risk of runtime crashes or unexpected behavior, unlike Objective-C where nil values can silently fail. Memory Management: Both Swift and Objective-C use Automatic Reference Counting (ARC) for memory management, but Swift‚Äôs syntax and stricter rules make it easier to avoid common pitfalls like retain cycles and dangling pointers. Objective-C‚Äôs more permissive nature increases the potential for memory-related errors. Bounds Checking: Swift automatically performs bounds checking on arrays and collections, which helps prevent buffer overflow vulnerabilities. In Objective-C, developers need to manually ensure that data access stays within valid bounds, increasing the risk of out-of-bounds errors. Immutable by Default: Swift encourages safer code by making constants (let) immutable by default. Objective-C requires the use of specific class types for immutability (e.g., NSString vs. NSMutableString), making the codebase more prone to unintended modifications if not carefully managed. Reduced Use of Unsafe Code: Swift avoids certain low-level operations, such as direct memory manipulation with pointers, that are more prevalent in Objective-C. This reduces the attack surface for exploits like buffer overflows and memory corruption. Enhanced Privacy and Security Practices: Swift‚Äôs language features align well with modern privacy regulations (e.g., GDPR, CCPA), supporting secure coding practices more intuitively and allowing developers to implement security measures more easily compared to Objective-C. These features make Swift a more secure choice for developing iOS applications, as it reduces common programming errors and provides built-in safeguards against many vulnerabilities." }, { "title" : "What is Swift Programming Language?", "category" : "", "tags" : " Development, iOS, Programming, Swift, Objective-C", "url" : "/what-is-swift/", "date" : "October 18, 2021", "excerpt" : "Swift is Apple‚Äôs modern, open-source programming language, introduced at Apple‚Äôs 2014 Worldwide Developers Conference (WWDC). Designed to be the successor to Objective-C, Swift is used for developing applications across all of Apple‚Äôs platforms, i...", "content" : "Swift is Apple‚Äôs modern, open-source programming language, introduced at Apple‚Äôs 2014 Worldwide Developers Conference (WWDC). Designed to be the successor to Objective-C, Swift is used for developing applications across all of Apple‚Äôs platforms, including iOS, macOS, watchOS, and tvOS. It primarily works with Apple‚Äôs Cocoa and Cocoa Touch frameworks. Since its introduction, Swift has rapidly become one of the fastest-growing programming languages. As an open-source language licensed under the Apache 2.0 license, Swift has extended beyond Apple‚Äôs ecosystem, finding use in other areas such as backend server development with frameworks like Vapor.Key Features of SwiftSwift was designed with several goals in mind: to be concise, expressive, fast, and less prone to errors (safer) than its predecessor, Objective-C. It introduces modern language features that make it easier to write reliable and maintainable code.The Architect of SwiftChris Lattner, the principal designer of Swift, was a key figure at Apple Inc., where he served as the Director of the Developer Tools department. In this role, he led the teams behind Xcode, Instruments, and the compiler technologies. Lattner is also the main author of LLVM (Low-Level Virtual Machine), a compiler infrastructure, and Clang, a compiler front end that replaces the GNU Compiler Collection and is designed to work atop LLVM. Chris Lattner (Twitter @clattner\\_llvm) Swift‚Äôs Versatility and Ease of LearningTo facilitate onboarding for newcomers, Swift can be used in various environments. One of the most accessible is the Swift Playgrounds, an interactive environment in Xcode, or through a web-based REPL (Read-Eval-Print Loop) like this one. A REPL provides a command-line interface that allows developers to experiment with Swift in an interpreted-like environment, making it easy to learn and test new code snippets quickly.Swift: A General-Purpose, Multi-Paradigm LanguageSwift is a type-safe, general-purpose, and multi-paradigm language. It supports a wide range of programming paradigms, including object-oriented, functional, and generic programming. This flexibility allows developers to use the most suitable style for a given problem, recognizing that no single paradigm is perfect for all use cases. Swift provides its own versions of common C and Objective-C types, alongside powerful data structures such as Arrays, Sets, and Dictionaries. Moreover, it includes unique types like tuples, which enable the passing of grouped values‚Äîa feature not available in Objective-C.Security &amp;amp; Swift/Objective-CWhile both Swift and Objective-C can be used to develop secure iOS applications, Swift offers several security advantages due to its modern language design: Type Safety and Optionals: Swift enforces strict type safety, reducing the risk of type-related errors that can lead to security vulnerabilities. Its use of optionals requires developers to handle nil values explicitly, minimizing the risk of runtime crashes or unexpected behavior, unlike Objective-C where nil values can silently fail. Memory Management: Both Swift and Objective-C use Automatic Reference Counting (ARC) for memory management, but Swift‚Äôs syntax and stricter rules make it easier to avoid common pitfalls like retain cycles and dangling pointers. Objective-C‚Äôs more permissive nature increases the potential for memory-related errors. Bounds Checking: Swift automatically performs bounds checking on arrays and collections, which helps prevent buffer overflow vulnerabilities. In Objective-C, developers need to manually ensure that data access stays within valid bounds, increasing the risk of out-of-bounds errors. Immutable by Default: Swift encourages safer code by making constants (let) immutable by default. Objective-C requires the use of specific class types for immutability (e.g., NSString vs. NSMutableString), making the codebase more prone to unintended modifications if not carefully managed. Reduced Use of Unsafe Code: Swift avoids certain low-level operations, such as direct memory manipulation with pointers, that are more prevalent in Objective-C. This reduces the attack surface for exploits like buffer overflows and memory corruption. Enhanced Privacy and Security Practices: Swift‚Äôs language features align well with modern privacy regulations (e.g., GDPR, CCPA), supporting secure coding practices more intuitively and allowing developers to implement security measures more easily compared to Objective-C. These features make Swift a more secure choice for developing iOS applications, as it reduces common programming errors and provides built-in safeguards against many vulnerabilities.Swift Projects and EcosystemThe Swift programming language is made up of several key components, each of which contributes to its versatility and power. According to Swift.org, these include: The Swift compiler, a command-line tool for compiling Swift code. The Standard Library, which provides essential functionality and is bundled with the language. Core Libraries that offer higher-level capabilities. The LLDB Debugger, which includes the Swift REPL, enabling debugging and interactive coding. The Swift Package Manager, a tool for managing and building Swift projects. Xcode Playground Support, which enables the use of playgrounds in Xcode for interactive coding.Swift continues to evolve, driven by contributions from both Apple and the open-source community. Its combination of speed, safety, and expressiveness makes it a strong choice for developers looking to build modern applications across multiple platforms." } ,  { "title" : "About Me", "category" : "", "tags" : " About", "url" : "/about-me/", "date" : "N/A", "excerpt" : "I‚Äôm Deya Eldeen, a mechatronic engineer with a deep passion for programming üë®üèª‚Äçüíª, design, and engineering üöÄ. This blog serves as a platform for me to share my insights and experiences related to Swift programming üßê. Here, you‚Äôll find discussions o...", "content" : "I‚Äôm Deya Eldeen, a mechatronic engineer with a deep passion for programming üë®üèª‚Äçüíª, design, and engineering üöÄ. This blog serves as a platform for me to share my insights and experiences related to Swift programming üßê. Here, you‚Äôll find discussions on various topics, including algorithms, data structures, design patterns, and different programming paradigms.My JourneyMy journey began at the age of 13 when I started creating 3D games using the Blender game engine. I worked as a full-time game developer throughout my college years, even before the advent of iPhone and Android. Today, I am proud to be a senior iOS Developer. üòÄRoadmap for Swift DevelopersCurrently, I‚Äôm developing a roadmap for Swift developers to assist newcomers in the iOS/Swift ecosystem, covering all relevant software engineering topics. My goal is to create a comprehensive guide that covers the essential concepts and best practices for building robust and efficient iOS applications using Swift.Sharing Knowledge and InsightsThrough this blog, I aim to share my knowledge and insights gained from years of experience in the field of iOS development. I believe that by sharing what I‚Äôve learned, I can help other developers grow and improve their skills. Whether you‚Äôre a beginner or an experienced developer, I hope you find my articles informative and valuable.Feedback and CollaborationI encourage you to reach out with any questions or feedback regarding my work. I‚Äôm always eager to learn from others and engage in discussions about the latest trends and best practices in iOS development. If you have a specific topic you‚Äôd like me to cover or if you‚Äôd like to collaborate on a project, please don‚Äôt hesitate to contact me.My Resume(Updated April 2024)Download ResumeI hope you enjoy exploring Swift By Deya! üöÄContactMy Email: deyaeldeenk@gmail.comTwitter: twitter.com/deya_eldeenGithub: github.com/deya-eldeenTelegram: @deyaeldeen" }, { "title" : "Blog Archive", "category" : "", "tags" : " ", "url" : "/archive/", "date" : "N/A", "excerpt" : "", "content" : "" }, { "title" : "Books", "category" : "", "tags" : " Books", "url" : "/books/", "date" : "N/A", "excerpt" : "BooksByte Magic In SwiftAuthors: Deya Eldeen ElkhawaldehDescription: Unlock the secrets of bitwise operators and elevate your Swift programming skills with ‚ÄúByte Magic In Swift‚Äù. This book takes you on an exhilarating journey, starting with the fu...", "content" : "BooksByte Magic In SwiftAuthors: Deya Eldeen ElkhawaldehDescription: Unlock the secrets of bitwise operators and elevate your Swift programming skills with ‚ÄúByte Magic In Swift‚Äù. This book takes you on an exhilarating journey, starting with the fundamentals and advancing to practical and advanced applications of bitwise operators. Pages: 170+Examples: 95+Download Digital Copy" },      { "title" : "Roadmaps", "category" : "", "tags" : " RoadMap", "url" : "/ios-road-map/", "date" : "N/A", "excerpt" : "Swift Roadmap:Swift LanguageSwift Object Oriented ProgrammingSwift NetworkingSwift ConcurrencySwift Protocol Oriented ProgrammingSwift Design PatternsSwift Data Structures and AlgorithmsSwift Functional ProgrammingSwift ArchitecturesRXSwiftCombine...", "content" : "Swift Roadmap:Swift LanguageSwift Object Oriented ProgrammingSwift NetworkingSwift ConcurrencySwift Protocol Oriented ProgrammingSwift Design PatternsSwift Data Structures and AlgorithmsSwift Functional ProgrammingSwift ArchitecturesRXSwiftCombineUnit TestingSwift Different TopicsiOS Road Map:XCodeInterface BuilderSwift NetworkingCoreDataCoreGraphicsCoreAnimationCoreVideoCoreAnimationSwiftUISensorsCombine" },            { "title" : "Tags", "category" : "", "tags" : " ", "url" : "/tags/", "date" : "N/A", "excerpt" : "", "content" : "" },           { } ,{ "title" : "Ninja", "category" : "", "tags" : " Lorem", "url" : "/portfolio/ninja", "date" : "April 8, 2014", "excerpt" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...", "content" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?" } ,{ "title" : "Creative", "category" : "", "tags" : " Ipsum", "url" : "/portfolio/safe", "date" : "August 16, 2014", "excerpt" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...", "content" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?Use this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons." } ,{ "title" : "Circus", "category" : "", "tags" : " Ipsum", "url" : "/portfolio/circus", "date" : "September 1, 2014", "excerpt" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...", "content" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?" } ,{ "title" : "Tower of Hanoi", "category" : "", "tags" : " ", "url" : "/portfolio/hanoi", "date" : "September 1, 2014", "excerpt" : "The tower of Hanoi‚Ä¶Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ip...", "content" : "The tower of Hanoi‚Ä¶Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?" } ,{ "title" : "Tic tac toe", "category" : "", "tags" : " ", "url" : "/portfolio/tictactoe", "date" : "September 1, 2014", "excerpt" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...", "content" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?Use this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons." } ,{ "title" : "Cake", "category" : "", "tags" : " Lorem, Ipsum", "url" : "/portfolio/cake", "date" : "September 27, 2015", "excerpt" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...", "content" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?Use this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons." } ,{ "title" : "Jekyll", "category" : "", "tags" : " ", "url" : "/portfolio/jekyllblog", "date" : "May 26, 2017", "excerpt" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...", "content" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?" } ,{ "title" : "Lorem Ipsum", "category" : "", "tags" : " ", "url" : "/portfolio/submarine", "date" : "September 3, 2017", "excerpt" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...", "content" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?Use this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons." } ,{ "title" : "Github", "category" : "", "tags" : " Lorem", "url" : "/portfolio/gitlecture", "date" : "October 20, 2017", "excerpt" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...", "content" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?" } ]
